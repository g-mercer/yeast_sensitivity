---
title: "insecticides_growthcurver"
author: "Guy Mercer"
date: "02/10/2020"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE)
```

Machine Settings:

* Number of Cycles - 192

* Cycle Length - 300s

* Wavelength - 600nm

* Temperature - 30°C

* Shake - Before Each Cycle (272s)

* Shake Mode - Double Orbital

* Shake Frequency - 200rpm

* Total Well Volume - 200µl

I combined all the replicates using zsh to output a formatted, compiled csv file called formatted_compiled. I then edited the names of controls and blanks.

```{zsh raw-file-formatting, echo = TRUE}
#!/usr/bin/env zsh

# setwd
cd /Users/guy/Documents/phd/DEG_yeast_insecticide_expt/senstivity_test/insecticides_sens

./WHATIDID.sh 
```

```{r, include = FALSE}
library(tidyverse)
library(knitr)
library(growthcurver)
library(pastecs)
library(ibd)
library(rstatix)
``` 

```{r, include = TRUE}
# display loaded R packages
r_packages <- installed.packages()[names(sessionInfo()$otherPkgs), "Version"]

r_packages_df <- as.data.frame(r_packages)

colnames(r_packages_df) <- c("Version")

kable(r_packages_df)
```

get data in right format, one column per well, one time column and one blank column. 

```{r, include = FALSE}
# set wd
setwd("~/Documents/phd/DEG_yeast_insecticide_expt/senstivity_test/insecticides_sens/")

# read csv
insect_sens <- read.csv(file = "./results/form_comp_corr_blank_cont.csv", header = FALSE, stringsAsFactors = FALSE)

# formatting function
sens_data_form <- function(sens_data) {
  # transpose
  sens_data_trans <- t(sens_data)
  # save first row as colnames
  colnames(sens_data_trans) <- sens_data_trans [1, ]
  # delete first row, which is now duplicate of colnames
  sens_data_colnames <- sens_data_trans [-1, ]
  # remove any empty rows. Sometimes created when importing csv file 
  sens_data_no_blanks <- sens_data_colnames[rowSums(is.na(sens_data_colnames)) != ncol(sens_data_colnames),]
  # convert matrix into dataframe
  sens_data_df <- as.data.frame(sens_data_no_blanks)
  # convert everything to numeric
  sens_data_df[] <- lapply(sens_data_df, function(x) {
    if(is.factor(x)) as.numeric(as.character(x)) else x
  })
  # convert to data frame
  sens_data_corr <- as.data.frame(sens_data_df)
  
  return(sens_data_corr)
}

sens_data_corr <- sens_data_form(insect_sens)

# set any negative values to 0
sens_data_corr[sens_data_corr<0] <- 0
```

Now the data is in the right format use Growthcurver. To retrieve r_se and r_p as well as the other summary information columns have to be looped through individually.

```{r, message = FALSE, fig.width = 7}
# Let's create an output data frame to store the results in. 
# We'll create it so that it is the right size (it's faster this way!), 
# but leave it empty.
num_analyses <- length(names(sens_data_corr)) - 1
d_gc <- data.frame(sample = character(num_analyses),
                   k = numeric(num_analyses),
                   n0  = numeric(num_analyses),
                   r = numeric(num_analyses),
                   r_se = numeric(num_analyses),
                   r_p = numeric(num_analyses),
                   t_mid = numeric(num_analyses),
                   t_gen = numeric(num_analyses),
                   auc_l = numeric(num_analyses),
                   auc_e = numeric(num_analyses),
                   sigma = numeric(num_analyses),
                   stringsAsFactors = FALSE)

# Now, loop through all of the columns in the data frame. For each column,
# run Growthcurver, save the most useful metrics in the output data frame,
# and make a plot of all the growth curve data and their best fits.
par(mfcol = c(8,12))
par(mar = c(0.25,0.25,0.25,0.25))
y_lim_max <- max(sens_data_corr[,setdiff(names(sens_data_corr), "time")]) - min(sens_data_corr[,setdiff(names(sens_data_corr), "time")])

n <- 1    # keeps track of the current row in the output data frame
for (col_name in names(sens_data_corr)) {
  
  # Don't process the column called "time". 
  # It contains time and not absorbance data.
  if (col_name != "time") {

    # Create a temporary data frame that contains just the time and current col
    sens_data_corr_loop <- sens_data_corr[, c("time", col_name)]
    
    # Now, call Growthcurver to calculate the metrics using SummarizeGrowth
    gc_fit <- SummarizeGrowth(data_t = sens_data_corr_loop[, "time"], 
                              data_n = sens_data_corr_loop[, col_name],
                              bg_correct = "none")
    
    # Now, add the metrics from this column to the next row (n) in the 
    # output data frame, and increment the row counter (n)
    d_gc$sample[n] <- col_name
    d_gc[n, 2:11] <- c(gc_fit$vals$k,
                      gc_fit$vals$n0,
                      gc_fit$vals$r,
                      gc_fit$vals$r_se,
                      gc_fit$vals$r_p,
                      gc_fit$vals$t_mid,
                      gc_fit$vals$t_gen,
                      gc_fit$vals$auc_l,
                      gc_fit$vals$auc_e,
                      gc_fit$vals$sigma)
    n <- n + 1
    
    # Finally, plot the raw data and the fitted curve
    n_obs <- length(gc_fit$data$t)
    plot(gc_fit$data$t, gc_fit$data$N, 
         pch = 20, 
         xlim = c(0, 960), 
         ylim = c(0, y_lim_max),
         cex = 0.6, xaxt = "n", yaxt = "n")
    text(x = 960 / 2, y = y_lim_max, labels = col_name, pos = 1)
    lines(gc_fit$data$t, predict(gc_fit$model),col = "red")
  }
}

# Uncomment the next line to save the plots from your 96-well plate to a file
# dev.off()
```

Sigma values represent the residual sum of squares from the fit of the logistic curve to the data, so larger values mean poorer fits.

```{R, eval = TRUE, message = FALSE}
d_gc <- as_tibble(d_gc)

# Plot a histogram of the sigma values in order to check for outliers
hist(d_gc$sigma, main = "Histogram of sigma values", xlab = "sigma")
```

Are my outliers high insecticide concentrations? Cypermethrin-5 had solubility issues, which resulted in the curve starting with artificially high OD readings. 7/8 Cypermethrin-5 are in the top 50 sigma scores. Not really surprising. 

``` {R, eval = FALSE, message = FALSE}
# Show the top 50 samples with the largest sigma value 
# (with the worst model fit to the growth curve data)
high_sigma <- d_gc %>% top_n(50, sigma) %>% arrange(desc(sigma))

high_sigma 
```

One additional method for identifying outlier parameters is to conduct a principal components analysis on the samples, which projects high dimensional data on lower dimensional space. Plotting the samples on the first two principal components (PC1 and PC2) can identify natural clusters within the growth curve data as well as outliers.

```{R, eval = TRUE, message = FALSE}
pca_gc_out <- as_data_frame(d_gc) 

# Prepare the gc_out data for the PCA
rownames(pca_gc_out) <- pca_gc_out$sample

# Do the PCA
pca.res <- prcomp(pca_gc_out %>% select(k:sigma), center=TRUE, scale=TRUE)

# Plot the results
as_tibble(list(PC1=pca.res$x[,1],
                   PC2=pca.res$x[,2],
                   samples = rownames(pca_gc_out))) %>% 
  ggplot(aes(x=PC1,y=PC2, label=samples)) + 
geom_text(size = 2)
```

When looking at the graph for thiacloprid-5-4 it is apparent it is an outlier.  

```{r}
# save a complete version of the data with all the outliers
growthcurver_data <- d_gc
```

Need to remove outliers through a combination of PCA, sigma values and visual inspection of plots. Removed chlorpyrifos-0.1-7, tefluthrin-0.1-7, control-5-7 (when I knocked the plate and droplet went on lid) and cypermethrin-5-3, thiacloprid-5-4, thiacloprid-5-5. 

Also a control is an anomaly but we need it for model (and associated incomplete block design) so keep it for now.

```{r}
# put control back into anomalies to see effect , "control-5-7"
anomalies <- c("chlorpyrifos-0.1-7", "tefluthrin-0.1-7", "thiacloprid-5-4", "thiacloprid-5-5")

for (names in anomalies) {
  
  d_gc <- d_gc %>% filter(sample != names)
  
}
```

Then, take AUC and r for remaining wells and calculate averages for each condition over the remaining replicates. How to incorporate standard error for individual r values in average r values? Then plot this onto a dose response curve (semi logarithmic). Is there any effect? Does r and AUC decrease with increasing pesticide concentration? Or no effect? Or unexpected effect, which might suggest incorrect experimental design (inaccurate initial cell number, solubility of cypermethrin, not all in mid-log phase growth at the beginning) 

```{r}
mean_plots_function <- function(d_gc) {
  
conditions_separately <- list()
conditions_stats <- tibble()

conditions <- c("control-", "acetamiprid-0.001", "acetamiprid-0.01", "acetamiprid-0.1", "acetamiprid-1","acetamiprid-5", "chlorpyrifos-0.001", "chlorpyrifos-0.01", "chlorpyrifos-0.1", "chlorpyrifos-1","chlorpyrifos-5", "clothianidin-0.001", "clothianidin-0.01", "clothianidin-0.1", "clothianidin-1","clothianidin-5", "cypermethrin-0.001", "cypermethrin-0.01", "cypermethrin-0.1", "cypermethrin-1", "cypermethrin-5", "flupyradifurone-0.001", "flupyradifurone-0.01", "flupyradifurone-0.1", "flupyradifurone-1","flupyradifurone-5", "imidacloprid-0.001", "imidacloprid-0.01", "imidacloprid-0.1", "imidacloprid-1","imidacloprid-5", "malathion-0.001", "malathion-0.01", "malathion-0.1", "malathion-1", "malathion-5", "sulfoxaflor-0.001", "sulfoxaflor-0.01", "sulfoxaflor-0.1", "sulfoxaflor-1", "sulfoxaflor-5", "tefluthrin-0.001", "tefluthrin-0.01", "tefluthrin-0.1", "tefluthrin-1", "tefluthrin-5", "thiacloprid-0.001", "thiacloprid-0.01", "thiacloprid-0.1", "thiacloprid-1", "thiacloprid-5")

for (name in 1:length(conditions)) {
  
  conditions_grouped <- d_gc %>% filter(str_detect(sample, conditions[name]))
  
  conditions_separately [name] <- conditions_grouped [ ,9]
  
  names(conditions_separately) [name] <- conditions[name]
  
  summ_stat <- stat.desc(conditions_separately[[name]])
  
  conditions_stats [name, 1] <- conditions[name]
  
  for (i in 1:length(summ_stat)) {
    
    conditions_stats [name, i+1] <- summ_stat [i]
    
  }
  
}

colnames(conditions_stats) <- c("condition", "nbr.val", "nbr.null", "nbr.na", "min", "max", "range", "sum", "median", "mean", "SE.mean", "CI.mean.0.95", "var", "std.dev", "coef.var")

# pull out condition AUC mean and AUC mean CI 95%
rel_conditions_stats <- conditions_stats [ , c(1, 10, 12)]

# separate each insecticide
insecticide_names <- c("acetamiprid", "chlorpyrifos", "clothianidin", "cypermethrin", "flupyradifurone", "imidacloprid", "malathion", "sulfoxaflor", "tefluthrin", "thiacloprid")

insecticide_list <- list()

for (name in 1:length(insecticide_names)) {

  insecticide_pattern <- paste0(insecticide_names[name], "-\\d*", sep = "")
  
  insecticide_x <- rel_conditions_stats %>% filter(str_detect(condition, insecticide_pattern))

  insecticide_list [[name]]  <- insecticide_x
  
  names(insecticide_list) [[name]] <- insecticide_names[name]
  
}

insecticide_list_1 <- list()

concentration <- c(0.001, 0.01, 0.1, 1, 5)

for (insecticide in 1:length(insecticide_list)) {
  
  insecticide_concs <- cbind(insecticide_list [[insecticide]], concentration)
  
  insecticide_list_1 [[insecticide]]  <- insecticide_concs
   
  names(insecticide_list_1) [[insecticide]] <- insecticide_names[insecticide]

}

# top sulfoxaflor concentration was 2.5 not 5
insecticide_list_1[[8]][5,4] <- as.numeric(gsub(5, 2.5, insecticide_list_1[[8]][5,4]))

# make control row
control_stats <- rel_conditions_stats %>% filter(str_detect(condition, "control"))
control_conc <- 0.0001
control_row <- cbind(control_stats, control_conc)
colnames(control_row) <- colnames(insecticide_list_1[[1]])

# bind it to the other insecticide dataframes
insecticide_list_2 <- list()

for (insecticide in 1:length(insecticide_list_1)) {
  
  insecticide_control <- rbind(insecticide_list_1 [[insecticide]], control_row)
  
  insecticide_list_2 [[insecticide]]  <- insecticide_control
   
  names(insecticide_list_2) [[insecticide]] <- insecticide_names[insecticide]

}

require(scales)

plot_list <- list()

for (insecticide in 1:length(insecticide_list_2)) {
  
  title <- paste0(names(insecticide_list_2[insecticide]), " dose-response curve", sep = "" )
  
  df <- insecticide_list_2[[insecticide]]

  df$facet <- ifelse(df$concentration == min(df$concentration), 1, 2)
  
  drc <- ggplot(df, aes(x=concentration,y=mean)) +
    geom_point(data = subset(df, facet == 1)) +
    geom_point(data = subset(df, facet == 2)) +
    scale_x_log10(breaks = c(0.0001, 10^(-3:10)), 
                labels = c(0, math_format()(-3:10))) +
    geom_errorbar(aes(ymin=mean-CI.mean.0.95, ymax=mean+CI.mean.0.95), width=.1) + 
    ylim(0, NA) +
    ggtitle(title) +
    labs(x="Concentration (log scale)", y="AUC",size=1) +
    facet_grid(~facet, scales = 'free', space = 'free') +
    theme(panel.background = element_rect(fill = "white"), plot.margin = margin(1, 1, 1, 1, "cm"),
    axis.line = element_line(), strip.text.x = element_blank(), plot.background = element_rect(
      fill = "grey90",
      colour = "black",
      size = 1
  )
  )
  
  plot_list [[insecticide]] <- drc

}

return(plot_list)

}

mean_plots <- mean_plots_function(d_gc)

mean_plots
```

Best option is to have three independent variables: concentration (continuous independent), pesticide (categorical independent) and day (categorical independent) and one dependent variable: AUC (continuous dependent). AUC = concentation + pesticide + day + (pesticide x concentration) (interaction) + (day x concentration) (interaction).  pesticide x concentration interaction is the interesting term. To do this the data has to be reformatted so there are columns with concentration, day and insecticide. At this point sulfoxaflor and cypermethrin were removed due to evaporation and solubility issues respectively. 

```{r}
aucl_formatting_function <- function(growthcurver_data, control_conc, aucl_or_r) {
  
  # subset from growthcurver_data the two required columns
  sample_area <- growthcurver_data [, c(1, aucl_or_r)]
  
  # remove sulfoxaflor and cypermethrin
  sample_area <- sample_area [-grep(pattern = "(cypermethrin|sulfoxaflor)", x = sample_area$sample), ]
  
  # add insecticide column to sample_area
  
  # create vector with remaining insecticides
  eight_insecticides <- c("acetamiprid", "chlorpyrifos", "clothianidin", "flupyradifurone", "imidacloprid", "malathion", "tefluthrin", "thiacloprid", "control")
  
  # create a df to save loop output in 
  sample_area_insecticide <- tibble()
  
  # extract individual insecticides, add insecticide column and recombine
  for (insecticide in 1:length(eight_insecticides)) {
    
    insecticide_alone <-  sample_area [grep(pattern = eight_insecticides [insecticide], x = sample_area$sample), ]
    
    insecticide_alone$insecticide <- eight_insecticides [insecticide]
    
    sample_area_insecticide <- rbind(sample_area_insecticide, insecticide_alone)
    
  }
  
  # add day to sample_area_insecticide
  
  # create day
  days <- c("one", "two", "three", "four", "five", "six", "seven", "eight")
  
  # create a df to save loop output in 
  sample_area_insecticide_day <- tibble()
  
  # extract individuals days, add day column and combine
  for (day in 1:length(days)) {
    
    day_pattern <- paste(".+-", day, "$", sep = "")
    
    day_alone <- sample_area_insecticide [grep(pattern = day_pattern, x = sample_area_insecticide$sample), ]
    
    day_alone$day <- days [day]
    
    sample_area_insecticide_day <- rbind(sample_area_insecticide_day, day_alone)
    
  }
  
  # add concentration to sample_area_insecticide_day
  
  # create concentration vector
  concentration_vector <- c(0.001, 0.01, 0.1, 1, 5)
  
  # create a df to save loop output in 
  sample_area_insecticide_day_concentration <- tibble()
  
  # extract individuals concentrations, add concentrations column and combine
  for (concentration in 1:length(concentration_vector)) {
    
    concentration_pattern <- paste(".+-", concentration_vector [concentration], "-.", sep = "")
    
    concentration_alone <- sample_area_insecticide_day [grep(pattern = concentration_pattern, x = sample_area_insecticide_day$sample), ]
    
    concentration_alone$concentration <- concentration_vector [concentration]
    
    sample_area_insecticide_day_concentration <- rbind(sample_area_insecticide_day_concentration, concentration_alone)
  }

  # extract controls
  controls_alone <- sample_area_insecticide_day_concentration [grep(pattern = "control", x = sample_area_insecticide_day_concentration$sample), ]
  
  # set correct sample name
  controls_alone$sample <- "control"
  
  # set correct concentration (0.0001 for making graphs)
  controls_alone$concentration <- control_conc
  
  # remove control rows from sample_area_insecticide_day_concentration
  sample_area_insecticide_day_concentration <- sample_area_insecticide_day_concentration [-grep(pattern = "control", x = sample_area_insecticide_day_concentration$sample), ]
  
  # add new control rows to sample_area_insecticide_day_concentration
  formatted_growthcurver_df <- rbind(sample_area_insecticide_day_concentration, controls_alone)
  
  return(formatted_growthcurver_df)

}

model_df_anomalies_removed <- aucl_formatting_function(growthcurver_data = d_gc, control_conc = 0, aucl_or_r = 9)
```

Look at the variation by day. This variation was probably introduced by yeast cells not all being in mid-log phase growth, or variation in initial yeast cell number added to each well. 

```{r}
model_df_anomalies_removed <- model_df_anomalies_removed %>%
  reorder_levels(day, order = c("one", "two", "three", "four", "five", "six", "seven", "eight"))

boxplot(auc_l ~ day, data = model_df_anomalies_removed)
```

I need to evenly distribute 40 controls amongst 8 insecticides so that the day effect will be minimised. This requires balanced incomplete block design. In my case I have 8 days (treatments in the examples, g), 8 blocks (insecticides, b), 5 days a block (k) and 5 replicates (r). In this case a BIBD doesn't exist because for 

r.(k-1) = λ.(g-1)

λ isn't a whole number. 

There is, however, an incomplete block design. The first output shows the block design and the second is a concurrence matrix and shows how many times any pair of treatments appears together in the same block. 
 
```{r}
bibd <- ibd(v = 8, b = 8, k = 5)

bibd$design

# shows how many days each block shares
bibd$conc.mat
```

following the block design above I need to allocate the controls to the insecticides. Remember the use of grep here. As I searched a specific column grep returned a row index, which can they be fed into normal subsetting via indexing. 

```{r}
ibd_control_assignment_function <- function(model_df_anomalies_removed) {

  only_controls <- model_df_anomalies_removed[grep("control", model_df_anomalies_removed$insecticide), ]

  insecticide_names <- c("acetamiprid", "chlorpyrifos", "clothianidin", "flupyradifurone", "imidacloprid", "malathion", "tefluthrin", "thiacloprid")

  # if i remove control again remember to change rep(7, each = 5) to rep(7, each = 4)
  only_controls$day_numerical <- rep(1:8, times = 5)

  model_df <- model_df_anomalies_removed[-grep("control", model_df_anomalies_removed$insecticide), ]

  for (insecticide in 1:length(insecticide_names)) {
  
    ibd_row <- bibd$design [insecticide, ]

    four_controls <- tibble()

    for (day in 1:length(ibd_row)) {
  
      ibd_day <- only_controls[grep(ibd_row [day], only_controls$day_numerical), ]
  
      random_control <- ibd_day[sample(nrow(ibd_day), 1), ]
  
      only_controls <- setdiff(only_controls, random_control)
  
      four_controls <- rbind(four_controls, random_control)
  
    }

    four_controls$insecticide <- gsub("control", insecticide_names [insecticide], four_controls$insecticide)

    model_df <- rbind(model_df, four_controls [ ,1:5])

  }
  
  return(model_df)

}

model_df_assigned_controls <- ibd_control_assignment_function(model_df_anomalies_removed)
```

Remember that when you run the chunk above you randomly assign the controls to the insecticides again according to the IBD. See if doing this varies the results. Would show the control assignment does have an effect. Could do because I'm using an incomplete block design.

What are the assumptions of linear regression?

First, build a simpler linear model:

AUC = insecticide + concentration + (insecticide * concentration)

The interesting part of the model is the interaction between insecticide and concentration.

```{r}
model_1 <- lm(auc_l ~ insecticide + concentration + insecticide*concentration, data = model_df_assigned_controls)

summary(model_1)
```

Add in day:

AUC = insecticide + concentration + day + (insecticide * concentration) 

```{r}
model_2 <- lm(auc_l ~ insecticide + concentration + day + insecticide*concentration, data = model_df_assigned_controls)

summary(model_2)
```

These are the only two models that mean anything biologically. Insecticide and concentration only mean something when taken together. I'm not doing an ANCOVA because that is to test for significance between an independent categorical variables and dependent continuous variables, controlling for an independent continuous variable. I am not controlling for this variable. Rather I am interested in the interaction between the one independent categorical variable (insecticide) and the independent continuous variable (concentration) and if that interaction is significantly associated with the response variable. 

```{r}
library(ggpubr)
library(rstatix)
library(broom)

# Fit the model, the covariate goes first
model_2 <- lm(auc_l ~ insecticide + concentration + day + insecticide*concentration, data = model_df_assigned_controls)
# Inspect the model diagnostic metrics
model.metrics <- augment(model_2) %>%
  select(-.hat, -.sigma, -.fitted) # Remove details

shapiro_test(model.metrics$.resid)
```

My residuals aren't normally distributed. Violates assumption of linear regression. Have to transform my data in some manner. Plot the residuals to get an idea of their distribution and the transformation necessary. 

Plot histogram and density kernal of residuals for model 2. Gives an 

```{r}
hist(model_df_assigned_controls$auc_l)
hist(model_2$residuals)
plot(density(model_2$residuals))
plot(model_2)
```

Data is slightly left skewed. Try all 16 combinations of square root, cube root, log  and untransformed dependent and log, square, cube root and untransformed of independent. All residuals non normal

```{r}
library(DescTools)

log_conc <- model_df_assigned_controls

# remove the outlier control

# log_conc <-  log_conc [grep(pattern = , x = ), ]

positive_skew_reflection <- 1100-(model_df_assigned_controls$auc_l)

hist(log_conc$auc_l)

hist(positive_skew_reflection)

# positive skew reflection transformation

log_conc$auc_l <- positive_skew_reflection

log_conc$auc_l <- log10(log_conc$auc_l)

# dependent variable transformations

# log_conc$auc_l <- log10(log_conc$auc_l)

# log_conc$auc_l <- sqrt(log_conc$auc_l)

# log_conc$auc_l <- (log_conc$auc_l)^(1/3)

# indepedent variable transformations

# log_conc$concentration <- LogSt(log_conc$concentration, base = 10, calib = log_conc$concentration, threshold = NULL, mult = 1)

# log_conc$concentration <- sqrt(log_conc$concentration)

# log_conc$concentration <- (log_conc$concentration)^(1/3)

model_3 <- lm(auc_l ~ insecticide + concentration + day + insecticide*concentration, data = log_conc)

summary(model_3)

plot(density(model_3$residuals))

# Inspect the model diagnostic metrics
model.metrics <- augment(model_3) #%>%
  #select(-.hat, -.sigma, -.fitted) # Remove details

shapiro_test(model.metrics$.resid)
```

Use fitdistrplus package to identify distribution of auc_l.

```{r}
library(fitdistrplus)

positive_skew <- 1100-(model_df_assigned_controls$auc_l)

# mirror images of each other. I have reflected the negative skew by subtracting each score from a 
# constant that is larger than the largest score. Skewness is the same magnitude but in the opposite direction.
plotdist(model_df_assigned_controls$auc_l, histo = TRUE, demp = TRUE)

descdist(model_df_assigned_controls$auc_l, boot = 1000)

plotdist(positive_skew, histo = TRUE, demp = TRUE)

descdist(positive_skew, boot = 1000)

fit_wb <-  fitdist(positive_skew, "weibull")

summary(fit_wb)

fit_ln <-  fitdist(positive_skew, "lnorm")

summary(fit_ln)

fit_g <-  fitdist(positive_skew, "gamma")

summary(fit_g)

par(mfrow = c(2, 2))

plot.legend <- c("weibull", "lognormal", "gamma")

denscomp(list(fit_wb, fit_ln, fit_g), legendtext = plot.legend)

qqcomp(list(fit_wb, fit_ln, fit_g), legendtext = plot.legend)

cdfcomp(list(fit_wb, fit_ln, fit_g), legendtext = plot.legend)
 
ppcomp(list(fit_wb, fit_ln, fit_g), legendtext = plot.legend)

gofstat(list(fit_wb, fit_ln, fit_g),  fitnames = c("weibull", "lognormal", "gamma"))

```

Looks like gamma is the best fit with the lowest AIC score, and lowest for the other three statistics. What I don't understand is how performing reflection and then log transforming the data didn't work because a lognormal distribution looks like a pretty good approximation apart from the at the distribution tail (QQ-plot). 

Plot individual replicates by day for each insecticide with a line connecting them. Sample with replacement for controls so all 8 insecticides can be visualised. Have to start with growthcurver_data because require previously filtered anomalies.

```{r}
formatted_growthcurver_df <- aucl_formatting_function(growthcurver_data = growthcurver_data, control_conc = 0.0001, aucl_or_r = 9)
```

Using this formatted df create plots of individual replicates for each insecticide. Assign controls randomly to insecticide by day with replacement. 

```{r}

insecticides_assigned_controls <- function(formatted_growthcurver_df) {
  
  # separate controls
  controls_alone <- formatted_growthcurver_df [grep(pattern = "control" , x = formatted_growthcurver_df$sample), ]

  # split controls into a list by day

  # create day
  days <- c("one", "two", "three", "four", "five", "six", "seven", "eight")
  
  # create day list
  control_day_list <- list()
  
  for (day in 1:length(days)) {
      
      control_by_day <- controls_alone [grep(pattern = days [day], x = controls_alone$day), ]
      
      control_day_list [[day]] <- control_by_day
      
  }
  
  # for each insecticide assign a random control from each day
  
  # create vector with remaining insecticides
  eight_insecticides <- c("acetamiprid", "chlorpyrifos", "clothianidin", "flupyradifurone", "imidacloprid", "malathion", "tefluthrin", "thiacloprid")
  
  # create empty df to store new data in
  controls_labelled_zero_insecticide <- tibble()
  
  for (insecticide in 1:length(eight_insecticides)) {
    
    insecticide_alone <-  formatted_growthcurver_df [grep(pattern = eight_insecticides [insecticide], x = formatted_growthcurver_df$sample), ]
    
    # create dataframe to save eight random controls, one from each day, in
    eight_random_controls <- tibble() 
    
    for (day in 1:length(days)) {
      
      random_control <- control_day_list [[day]] [sample(nrow(control_day_list [[day]]), 1, replace = TRUE, prob = NULL), ]
      
      eight_random_controls <- rbind(eight_random_controls, random_control)
    }
    
    eight_random_controls$insecticide <-  eight_insecticides [insecticide]
    
    insecticide_and_controls <- rbind(insecticide_alone, eight_random_controls)
    
    controls_labelled_zero_insecticide <- rbind(controls_labelled_zero_insecticide, insecticide_and_controls)
    
  }
  
  return(controls_labelled_zero_insecticide)
}

assigned_controls_df <- insecticides_assigned_controls(formatted_growthcurver_df)

```

Split by insecticide

```{r}
by_insecticide_df_function <- function(assigned_controls_df) {
  
  # split assigned_controls_df into 8 lists by insecticide. Also split each insecticide by day. 

  # define 8 insecticides
  eight_insecticides <- c("acetamiprid", "chlorpyrifos", "clothianidin", "flupyradifurone", "imidacloprid", "malathion", "tefluthrin", "thiacloprid")
  
  # create list to save loop output
  insecticide_list <- list()
  
  # split insecticides into their own dfs within a list
  for (insecticide in 1:length(eight_insecticides)) {
    
    insecticide_alone <- assigned_controls_df [grep(pattern = eight_insecticides [insecticide], x = assigned_controls_df$insecticide), ]
    
    insecticide_list [[insecticide]] <- insecticide_alone
    
    names(insecticide_list) [[insecticide]] <- eight_insecticides[insecticide]
    
  }
  
  return(insecticide_list)
  
}

by_insecticide_dfs <- by_insecticide_df_function(assigned_controls_df)

```

Plot

```{r}
require(scales)

plot_list <- list()

for (insecticide in 1:length(by_insecticide_dfs)) {
  
  title <- paste0(names(by_insecticide_dfs[insecticide]), " dose-response curve", sep = "" )
  
  df <- by_insecticide_dfs[[insecticide]]

  # introduces axis break.
  df$facet <- ifelse(df$concentration == min(df$concentration), 1, 2)
  
  drc <- ggplot(df, aes(x=concentration,y=auc_l, color=day)) +
    geom_point(data = subset(df, facet == 1)) +
    geom_point(data = subset(df, facet == 2)) +
    geom_line() +
    scale_x_log10(breaks = c(0.0001, 10^(-3:10)), 
                labels = c(0, math_format()(-3:10))) +
    ylim(0, NA) +
    ggtitle(title) +
    labs(x="Concentration (log scale)", y="AUC",size=1) +
    facet_grid(~facet, scales = 'free', space = 'free') +
    theme(panel.background = element_rect(fill = "white"), plot.margin = margin(1, 1, 1, 1, "cm"),
    axis.line = element_line(), strip.text.x = element_blank(), plot.background = element_rect(
      fill = "grey90",
      colour = "black",
      size = 1
  )
  )
  
  plot_list [[insecticide]] <- drc

}

plot_list

```

Above I can introduce the axis break but not line connecting all points. Below I can connect all points but not have axis break. 

```{r}
plot_list <- list()

for (insecticide in 1:length(by_insecticide_dfs)) {
  
  title <- paste0(names(by_insecticide_dfs[insecticide]), " dose-response curve", sep = "" )
  
  df <- by_insecticide_dfs[[insecticide]]

  drc <- ggplot(df, aes(x=concentration,y=auc_l, color=day)) +
    geom_point() +
    geom_line() +
    scale_x_log10(breaks = c(0.0001, 10^(-3:10)), 
                labels = c(0, math_format()(-3:10))) +
    ylim(0, NA) +
    ggtitle(title) +
    labs(x="Concentration (log scale)", y="AUC",size=1) +
    theme(panel.background = element_rect(fill = "white"), plot.margin = margin(1, 1, 1, 1, "cm"),
    axis.line = element_line(), strip.text.x = element_blank(), plot.background = element_rect(
      fill = "grey90",
      colour = "black",
      size = 1
  )
  )
  
  plot_list [[insecticide]] <- drc

}

plot_list
```

All displayed at once

```{r}

title <- "replicates by day for insecticides"

drc <- ggplot(assigned_controls_df, aes(x=concentration,y=auc_l, color=day)) +
  facet_wrap(~ insecticide) +
  geom_point() +
  geom_line() +
  scale_x_log10(breaks = c(0.0001, 10^(-3:10)), 
                labels = c(0, math_format()(-3:10))) +
  ylim(0, NA) +
  ggtitle(title) +
  labs(x="Concentration (log scale)", y="AUC",size=1) +
theme(panel.background = element_rect(fill = "white"), plot.margin = margin(1, 1, 1, 1, "cm"),
  axis.line = element_line(), plot.background = element_rect(
    fill = "grey90",
    colour = "black",
    size = 1
  )
  )

 drc
```

At some point have to transform data. 

Does looking at growth rate (r) change any of the results. 

```{r}
model_df_anomalies_removed_r <- aucl_formatting_function(growthcurver_data = d_gc, control_conc = 0, aucl_or_r = 4)

model_df_assigned_controls_r <- ibd_control_assignment_function(model_df_anomalies_removed_r)

model_1_r <- lm(r ~ insecticide + concentration + insecticide*concentration, data = model_df_assigned_controls_r)

summary(model_1_r)

model_2_r <- lm(r ~ insecticide + concentration + day + insecticide*concentration, data = model_df_assigned_controls_r)

summary(model_2_r)
```

model output is the same. Less of the variation described by the model though.

```{r}
formatted_growthcurver_df_r <- aucl_formatting_function(growthcurver_data = growthcurver_data, control_conc = 0.0001, aucl_or_r = 4)

assigned_controls_df_r <- insecticides_assigned_controls(formatted_growthcurver_df_r)

by_insecticide_dfs_r <- by_insecticide_df_function(assigned_controls_df_r)

plot_list <- list()

for (insecticide in 1:length(by_insecticide_dfs_r)) {
  
  title <- paste0(names(by_insecticide_dfs_r[insecticide]), " dose-response curve", sep = "" )
  
  df <- by_insecticide_dfs_r[[insecticide]]
  
  drc <- ggplot(df, aes(x=concentration,y=r, color=day)) +
    geom_point() +
    geom_line() +
    scale_x_log10(breaks = c(0.0001, 10^(-3:10)), 
                  labels = c(0, math_format()(-3:10))) +
    ylim(0, NA) +
    ggtitle(title) +
    labs(x="Concentration (log scale)", y="AUC",size=1) +
    theme(panel.background = element_rect(fill = "white"), plot.margin = margin(1, 1, 1, 1, "cm"),
          axis.line = element_line(), strip.text.x = element_blank(), plot.background = element_rect(
            fill = "grey90",
            colour = "black",
            size = 1
          )
    )
  
  plot_list [[insecticide]] <- drc
  
}

plot_list

```

The growth rate (r) plots for include thiacloprid-5-4 and thiacloprid-5-5, which were both anomalies. They were removed from the model. Make the trend look stronger than it is. Reason r was lower for these is OD started higher due to experimental error, so maximal growth rate wasn't detected as OD readings were artificially elevated above the stage where maximal growth occurs. 





Just Thiacloprid

```{r}
# linear model
thiacloprid <- model_df_assigned_controls [grep(pattern = "thiacloprid", x = model_df_assigned_controls$insecticide), ]

model_4 <- lm(auc_l ~ concentration + day, data = thiacloprid)

summary(model_4)

plot(model_4)

plot(density(model_4$residuals))

# Inspect the model diagnostic metrics
model.metrics_thia <- augment(model_4) %>%
  select(-.hat, -.sigma, -.fitted) # Remove details

shapiro_test(model.metrics_thia$.resid)

# mixed model
library(lme4)

thiacloprid_mm <- lmer(auc_l ~ concentration + (1|day), data = thiacloprid)

summary(thiacloprid_mm)
```

Day explains 56.7% of the variance remaining after the variance explained by fixed effects. Intercept and slope comparable between linear and mixed model. 