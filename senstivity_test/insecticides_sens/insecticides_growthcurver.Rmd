---
title: "insecticides_growthcurver"
author: "Guy Mercer"
date: "02/10/2020"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE)
```

Machine Settings:

* Number of Cycles - 192

* Cycle Length - 300s

* Wavelength - 600nm

* Temperature - 30°C

* Shake - Before Each Cycle (272s)

* Shake Mode - Double Orbital

* Shake Frequency - 200rpm

* Total Well Volume - 200µl

I combined all the replicates using zsh to output a formatted, compiled csv file called formatted_compiled. I then edited the names of controls and blanks.

```{zsh raw-file-formatting, echo = TRUE}
#!/usr/bin/env zsh

# setwd
cd /Users/guy/Documents/phd/DEG_yeast_insecticide_expt/senstivity_test/insecticides_sens

./WHATIDID.sh 

```

```{r, include = FALSE}
library(tidyverse)
library(knitr)
library(growthcurver)
library(pastecs)
library(ibd)
library(rstatix)
``` 
```{r, include = TRUE}
r_packages <- installed.packages()[names(sessionInfo()$otherPkgs), "Version"]

r_packages_df <- as.data.frame(r_packages)

colnames(r_packages_df) <- c("Version")

kable(r_packages_df)
```

get data in right format, one column per well, one time column and one blank column. 

```{r, include = FALSE}
# set wd
setwd("~/Documents/phd/DEG_yeast_insecticide_expt/senstivity_test/insecticides_sens/")
# read csv
insect_sens <- read.csv(file = "./results/form_comp_corr_blank_cont.csv", header = FALSE, stringsAsFactors = FALSE)

sens_data_form <- function(sens_data) {
  # transpose
  sens_data_trans <- t(sens_data)
  # save first row as colnames
  colnames(sens_data_trans) <- sens_data_trans [1, ]
  # delete first row, which is now duplicate of colnames
  sens_data_colnames <- sens_data_trans [-1, ]
  # remove any empty rows. Sometimes created when importing csv file 
  sens_data_no_blanks <- sens_data_colnames[rowSums(is.na(sens_data_colnames)) != ncol(sens_data_colnames),]
  # convert matrix into dataframe
  sens_data_df <- as.data.frame(sens_data_no_blanks)
  # convert everything to numeric
  sens_data_df[] <- lapply(sens_data_df, function(x) {
    if(is.factor(x)) as.numeric(as.character(x)) else x
  })
  # convert to data frame
  sens_data_corr <- as.data.frame(sens_data_df)
}

sens_data_corr <- sens_data_form(insect_sens)

# set any negative values to 0
sens_data_corr[sens_data_corr<0] <- 0
```

```{r}
# useful command for filtering column contents
# gc_out_filtered <- gc_out %>% filter(note != "cannot fit data") 
```

Now the data is in the right format use Growthcurver. To retrieve r_se and r_p as well as the other summary information columns have to be looped through individually.

```{r, message = FALSE, fig.width = 7}
# Let's create an output data frame to store the results in. 
# We'll create it so that it is the right size (it's faster this way!), 
# but leave it empty.
num_analyses <- length(names(sens_data_corr)) - 1
d_gc <- data.frame(sample = character(num_analyses),
                   k = numeric(num_analyses),
                   n0  = numeric(num_analyses),
                   r = numeric(num_analyses),
                   r_se = numeric(num_analyses),
                   r_p = numeric(num_analyses),
                   t_mid = numeric(num_analyses),
                   t_gen = numeric(num_analyses),
                   auc_l = numeric(num_analyses),
                   auc_e = numeric(num_analyses),
                   sigma = numeric(num_analyses),
                   stringsAsFactors = FALSE)

# Now, loop through all of the columns in the data frame. For each column,
# run Growthcurver, save the most useful metrics in the output data frame,
# and make a plot of all the growth curve data and their best fits.

par(mfcol = c(8,12))
par(mar = c(0.25,0.25,0.25,0.25))
y_lim_max <- max(sens_data_corr[,setdiff(names(sens_data_corr), "time")]) - min(sens_data_corr[,setdiff(names(sens_data_corr), "time")])

n <- 1    # keeps track of the current row in the output data frame
for (col_name in names(sens_data_corr)) {
  
  # Don't process the column called "time". 
  # It contains time and not absorbance data.
  if (col_name != "time") {

    # Create a temporary data frame that contains just the time and current col
    sens_data_corr_loop <- sens_data_corr[, c("time", col_name)]
    
    # Now, call Growthcurver to calculate the metrics using SummarizeGrowth
    gc_fit <- SummarizeGrowth(data_t = sens_data_corr_loop[, "time"], 
                              data_n = sens_data_corr_loop[, col_name],
                              bg_correct = "none")
    
    # Now, add the metrics from this column to the next row (n) in the 
    # output data frame, and increment the row counter (n)
    d_gc$sample[n] <- col_name
    d_gc[n, 2:11] <- c(gc_fit$vals$k,
                      gc_fit$vals$n0,
                      gc_fit$vals$r,
                      gc_fit$vals$r_se,
                      gc_fit$vals$r_p,
                      gc_fit$vals$t_mid,
                      gc_fit$vals$t_gen,
                      gc_fit$vals$auc_l,
                      gc_fit$vals$auc_e,
                      gc_fit$vals$sigma)
    n <- n + 1
    
    # Finally, plot the raw data and the fitted curve
    # Here, I'll just print some of the data points to keep the file size smaller
    n_obs <- length(gc_fit$data$t)
    plot(gc_fit$data$t, gc_fit$data$N, 
         pch = 20, 
         xlim = c(0, 960), 
         ylim = c(0, y_lim_max),
         cex = 0.6, xaxt = "n", yaxt = "n")
    text(x = 960 / 2, y = y_lim_max, labels = col_name, pos = 1)
    lines(gc_fit$data$t, predict(gc_fit$model),col = "red")
  }
}

# Uncomment the next line to save the plots from your 96-well plate to a file
# dev.off()
```

Sigma values represent the residual sum of squares from the fit of the logistic curve to the data, so larger values mean poorer fits.

```{R, eval = TRUE, message = FALSE}
d_gc <- as_data_frame(d_gc)

# Plot a histogram of the sigma values in order to check for outliers
hist(d_gc$sigma, main = "Histogram of sigma values", xlab = "sigma")

```

Are my outliers high insecticide concentrations? Cypermethrin-5 had solubility issues, which resulted in the curve starting with artificially high OD readings. 7/8 Cypermethrin-5 are in the top 50 sigma scores. Not really surprising. 

``` {R, eval = FALSE, message = FALSE}
# Show the top 50 samples with the largest sigma value 
# (with the worst model fit to the growth curve data)
high_sigma <- d_gc %>% top_n(50, sigma) %>% arrange(desc(sigma))

high_sigma 
```

One additional method for identifying outlier parameters is to conduct a principal components analysis on the samples, which projects high dimensional data on lower dimensional space. Plotting the samples on the first two principal components (PC1 and PC2) can identify natural clusters within the growth curve data as well as outliers.

```{R, eval = TRUE, message = FALSE}


pca_gc_out <- as_data_frame(d_gc) 

# Prepare the gc_out data for the PCA
rownames(pca_gc_out) <- pca_gc_out$sample

# Do the PCA
pca.res <- prcomp(pca_gc_out %>% select(k:sigma), center=TRUE, scale=TRUE)

# Plot the results
as_data_frame(list(PC1=pca.res$x[,1],
                   PC2=pca.res$x[,2],
                   samples = rownames(pca_gc_out))) %>% 
  ggplot(aes(x=PC1,y=PC2, label=samples)) + 
  geom_text(size = 2)
```

When looking at the graph for thiacloprid-5-4 it is apparent it is an outlier.  

```{r}
# useful command for filtering column contents
# gc_out_filtered <- gc_out %>% filter(note != "cannot fit data") 
```

Need to remove outliers through a combination of PCA, sigma values and visual inspection of plots. Removed chlorpyrifos-0.1-7, tefluthrin-0.1-7, control-5-7 (when I knocked the plate and droplet went on lid) and cypermethrin-5-3, cypermethrin-5-6, thiacloprid-5-4, thiacloprid-5-5. 

"cypermethrin-5-1", "cypermethrin-5-2", "cypermethrin-5-3", "cypermethrin-5-4", "cypermethrin-5-5", "cypermethrin-5-6", "cypermethrin-5-7", "cypermethrin-5-8"

```{r}

anomalies <- c("chlorpyrifos-0.1-7", "tefluthrin-0.1-7", "control-5-7", "thiacloprid-5-4", "thiacloprid-5-5")

for (names in anomalies) {
  
  d_gc <- d_gc %>% filter(sample != names)
  
}

```

Then, take AUC and r for remaining wells and calculate averages for each condition over the remaining replicates. How to incorporate standard error for individual r values in average r values? 

```{r}
conditions_separately <- list()
conditions_stats <- tibble()

conditions <- c("control-", "acetamiprid-0.001", "acetamiprid-0.01", "acetamiprid-0.1", "acetamiprid-1","acetamiprid-5", "chlorpyrifos-0.001", "chlorpyrifos-0.01", "chlorpyrifos-0.1", "chlorpyrifos-1","chlorpyrifos-5", "clothianidin-0.001", "clothianidin-0.01", "clothianidin-0.1", "clothianidin-1","clothianidin-5", "cypermethrin-0.001", "cypermethrin-0.01", "cypermethrin-0.1", "cypermethrin-1", "cypermethrin-5", "flupyradifurone-0.001", "flupyradifurone-0.01", "flupyradifurone-0.1", "flupyradifurone-1","flupyradifurone-5", "imidacloprid-0.001", "imidacloprid-0.01", "imidacloprid-0.1", "imidacloprid-1","imidacloprid-5", "malathion-0.001", "malathion-0.01", "malathion-0.1", "malathion-1", "malathion-5", "sulfoxaflor-0.001", "sulfoxaflor-0.01", "sulfoxaflor-0.1", "sulfoxaflor-1", "sulfoxaflor-5", "tefluthrin-0.001", "tefluthrin-0.01", "tefluthrin-0.1", "tefluthrin-1", "tefluthrin-5", "thiacloprid-0.001", "thiacloprid-0.01", "thiacloprid-0.1", "thiacloprid-1", "thiacloprid-5")

for (name in 1:length(conditions)) {
  
  conditions_grouped <- d_gc %>% filter(str_detect(sample, conditions[name]))
  
  conditions_separately [name] <- conditions_grouped [ ,9]
  
  names(conditions_separately) [name] <- conditions[name]
  
  summ_stat <- stat.desc(conditions_separately[[name]])
  
  conditions_stats [name, 1] <- conditions[name]
  
  for (i in 1:length(summ_stat)) {
    
    conditions_stats [name, i+1] <- summ_stat [i]
    
  }
  
}

colnames(conditions_stats) <- c("condition", "nbr.val", "nbr.null", "nbr.na", "min", "max", "range", "sum", "median", "mean", "SE.mean", "CI.mean.0.95", "var", "std.dev", "coef.var")

```

Then plot this onto a dose response curve (semi logarithmic). Is there any effect? Does r and AUC decrease with increasing pesticide concentration? Or no effect? Or unexpected effect, which might suggest incorrect experimental design (inaccurate initial cell number, solubility of cypermethrin, not all in mid-log phase growth at the beginning)

```{r}
# pull out condition AUC mean and AUC mean CI 95%
rel_conditions_stats <- conditions_stats [ , c(1, 10, 12)]

# separate each insecticide
insecticide_names <- c("acetamiprid", "chlorpyrifos", "clothianidin", "cypermethrin", "flupyradifurone", "imidacloprid", "malathion", "sulfoxaflor", "tefluthrin", "thiacloprid")

insecticide_list <- list()

for (name in 1:length(insecticide_names)) {

  insecticide_pattern <- paste0(insecticide_names[name], "-\\d*", sep = "")
  
  insecticide_x <- rel_conditions_stats %>% filter(str_detect(condition, insecticide_pattern))

  insecticide_list [[name]]  <- insecticide_x
  
  names(insecticide_list) [[name]] <- insecticide_names[name]
}

insecticide_list_1 <- list()

concentration <- c(0.001, 0.01, 0.1, 1, 5)

for (insecticide in 1:length(insecticide_list)) {
  
   insecticide_concs <- cbind(insecticide_list [[insecticide]], concentration)
  
   insecticide_list_1 [[insecticide]]  <- insecticide_concs
   
   names(insecticide_list_1) [[insecticide]] <- insecticide_names[insecticide]

}

# top sulfoxaflor concentration was 2.5 not 5
insecticide_list_1[[8]][5,4] <- as.numeric(gsub(5, 2.5, insecticide_list_1[[8]][5,4]))
class(insecticide_list_1[[8]][5,4])
```

```{r}
  # make control row
  control_stats <- rel_conditions_stats %>% filter(str_detect(condition, "control"))
  control_conc <- 0.0001
  control_row <- cbind(control_stats, control_conc)
  colnames(control_row) <- colnames(insecticide_list_1[[1]])
  
  # bind it to the other insecticide dataframes
  insecticide_list_2 <- list()

for (insecticide in 1:length(insecticide_list_1)) {
  
   insecticide_control <- rbind(insecticide_list_1 [[insecticide]], control_row)
  
   insecticide_list_2 [[insecticide]]  <- insecticide_control
   
   names(insecticide_list_2) [[insecticide]] <- insecticide_names[insecticide]

}
```

```{r}
require(scales)

plot_list <- list()

for (insecticide in 1:length(insecticide_list_2)) {
  
  title <- paste0(names(insecticide_list_2[insecticide]), " dose-response curve", sep = "" )
  
  df <- insecticide_list_2[[insecticide]]

  df$facet <- ifelse(df$concentration == min(df$concentration), 1, 2)
  
  drc <- ggplot(df, aes(x=concentration,y=mean)) +
    geom_point(data = subset(df, facet == 1)) +
    geom_point(data = subset(df, facet == 2)) +
    scale_x_log10(breaks = c(0.0001, 10^(-3:10)), 
                labels = c(0, math_format()(-3:10))) +
    geom_errorbar(aes(ymin=mean-CI.mean.0.95, ymax=mean+CI.mean.0.95), width=.1) + 
    ylim(0, NA) +
    ggtitle(title) +
    labs(x="Concentration (log scale)", y="AUC",size=1) +
    facet_grid(~facet, scales = 'free', space = 'free') +
    theme(panel.background = element_rect(fill = "white"), plot.margin = margin(1, 1, 1, 1, "cm"),
    axis.line = element_line(), strip.text.x = element_blank(), plot.background = element_rect(
      fill = "grey90",
      colour = "black",
      size = 1
  )
  )
  
  plot_list [[insecticide]] <- drc

}

plot_list

```

Look at the insecticides one by one. Doesn't make sense to me to convert 10 continuous independent variables into one categorical variable where linear regression would have to be dummy coded in. Contentious point. 

```{r}

# create a column for the day (categorical independent variable)
sample_a <- d_gc [ , c(1,9)]

days <- c("one", "two", "three", "four", "five", "six", "seven", "eight")

sample_au <-  tibble()

for (day in 1:length(days)) {
  
  day_pattern <- paste0("\\w*-.*-", day, sep = "")
  
  day_x <- sample_a %>% filter(str_detect(sample, day_pattern))
  
  day_x$day <- days [day]
  
 sample_au <- rbind(sample_au, day_x)
}

# create a column for the insecticide and control
insecticide_control_name <- c(insecticide_names, "control")
sample_auc <-  tibble()

for (insecticide in 1:length(insecticide_control_name)) {
  
  by_insecticide <- sample_au %>% filter(str_detect(sample, insecticide_control_name [insecticide]))
  
  by_insecticide$insecticide <- insecticide_control_name [insecticide]
  
  sample_auc <- rbind(sample_auc, by_insecticide)

}

# give controls same name
names <- sample_auc$sample

sample_auc_control <- str_replace_all(names, "control-.*-\\d$", "control")

sample_auc [ , 1] <- sample_auc_control

# create a column for the concentration, add controls separately
sample_aucl <- tibble()

for (conc in 1:length(concentration)) {
  
  indiv_conc <- paste0("\\w*-", concentration [conc], "-", sep = "")
  
  by_concentration <- sample_auc %>% filter(str_detect(sample, indiv_conc))
  
  by_concentration$concentration <- concentration [conc]
  
  sample_aucl <- rbind(sample_aucl, by_concentration)
  
}

controls_sep <- sample_auc %>% filter(str_detect(sample, "control"))

controls_sep$concentration <- 0

sample_aucl <- rbind(sample_aucl, controls_sep)

# give replicates same name for each group.
names <- sample_aucl$sample

sample_aucl_control <- str_replace_all(names, "control-.*-\\d$", "control")

sample_aucl [ , 1] <- sample_aucl_control

replicate_name <- sample_aucl$sample

replicate_same_names <- tibble()

for (name in 1:length(replicate_name)) {
  
  same_name <- str_replace_all(sample_aucl [name, 1], "-\\d$", "")

  replicate_same_names [name, 1] <- same_name
    
}

sample_aucl [, 1] <- replicate_same_names 

# separate replicates for each insecticide with the control
insecticide_names <- c("acetamiprid", "chlorpyrifos", "clothianidin", "cypermethrin", "flupyradifurone", "imidacloprid", "malathion", "sulfoxaflor", "tefluthrin", "thiacloprid")

# make control rows
controls <- sample_aucl %>% filter(str_detect(sample, "control"))

replicate_insect_control <- list()

for (name in 1:length(insecticide_names)){
  
  insecticide_x <- sample_aucl %>% filter(str_detect(sample, insecticide_names[name]))
  
  insecticide_x_control <- rbind(insecticide_x, controls)

  replicate_insect_control [[name]]  <- insecticide_x_control
  
  names(replicate_insect_control) [[name]] <- insecticide_names[name]

}
```

```{r}
# convert character names into corresponding numerical concentrations for each insecticide. Obviously need to try and loop this.
replicate_insect_control$acetamiprid$sample <- str_replace_all(replicate_insect_control$acetamiprid$sample, "control", "0") %>% str_replace_all("\\w*-", "") %>% as.numeric()
replicate_insect_control$chlorpyrifos$sample <- str_replace_all(replicate_insect_control$chlorpyrifos$sample, "control", "0") %>% str_replace_all("\\w*-", "") %>% as.numeric()
replicate_insect_control$clothianidin$sample <- str_replace_all(replicate_insect_control$clothianidin$sample, "control", "0") %>% str_replace_all("\\w*-", "") %>% as.numeric()
replicate_insect_control$cypermethrin$sample <- str_replace_all(replicate_insect_control$cypermethrin$sample, "control", "0") %>% str_replace_all("\\w*-", "") %>% as.numeric()
replicate_insect_control$flupyradifurone$sample <- str_replace_all(replicate_insect_control$flupyradifurone$sample, "control", "0") %>% str_replace_all("\\w*-", "") %>% as.numeric()
replicate_insect_control$imidacloprid$sample <- str_replace_all(replicate_insect_control$imidacloprid$sample, "control", "0") %>% str_replace_all("\\w*-", "") %>% as.numeric()
replicate_insect_control$malathion$sample <- str_replace_all(replicate_insect_control$malathion$sample, "control", "0") %>% str_replace_all("\\w*-", "") %>% as.numeric()
replicate_insect_control$sulfoxaflor$sample <- str_replace_all(replicate_insect_control$sulfoxaflor$sample, "control", "0") %>% str_replace_all("\\w*-", "") %>% as.numeric()
replicate_insect_control$tefluthrin$sample <- str_replace_all(replicate_insect_control$tefluthrin$sample, "control", "0") %>% str_replace_all("\\w*-", "") %>% as.numeric()
replicate_insect_control$thiacloprid$sample <- str_replace_all(replicate_insect_control$thiacloprid$sample, "control", "0") %>% str_replace_all("\\w*-", "") %>% as.numeric()

```

Now the data has the right structure and class I can create some linear models and check if they are a good fit. Cost: decreasing sample size and increasing chance of Type 1 error (false positive, incorrectly rejecting the null hypothesis). 

```{r}

insecticide_linear_models <- list()

model_summaries <- list()

for (insecticide in 1:length(replicate_insect_control)) {
  
  insecticide_lm <- lm(auc_l ~ sample, data = replicate_insect_control [[insecticide]]) 
  
  insecticide_linear_models [[insecticide]] <- insecticide_lm
  
  names(insecticide_linear_models) [[insecticide]] <- names(replicate_insect_control) [[insecticide]] 
  
  model_summaries [[insecticide]] <- summary(insecticide_linear_models [[insecticide]])
  
  names(model_summaries) [[insecticide]] <- names(replicate_insect_control) [[insecticide]] 

}

 model_summaries

```

Look at the variation by day. This variation was probably introduced by yeast cells not all being in mid-log phase growth, or variation in initial yeast cell number added to each well. 

```{r}

sample_aucl <- sample_aucl %>%
  reorder_levels(day, order = c("one", "two", "three", "four", "five", "six", "seven", "eight"))

boxplot(auc_l ~ day, data = sample_aucl)
```

