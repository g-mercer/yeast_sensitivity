---
title: "insecticides_growthcurver"
author: "Guy Mercer"
date: "02/10/2020"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE)
```

Machine Settings:

* Number of Cycles - 192

* Cycle Length - 300s

* Wavelength - 600nm

* Temperature - 30°C

* Shake - Before Each Cycle (272s)

* Shake Mode - Double Orbital

* Shake Frequency - 200rpm

* Total Well Volume - 200µl

I combined all the replicates using zsh to output a formatted, compiled csv file called formatted_compiled. I then edited the names of controls and blanks.

```{zsh raw-file-formatting, echo = TRUE}
#!/usr/bin/env zsh

# setwd
cd /Users/guy/Documents/phd/DEG_yeast_insecticide_expt/senstivity_test/insecticides_sens

./WHATIDID.sh 

```

```{r, include = FALSE}
library(tidyverse)
library(knitr)
library(growthcurver)
library(pastecs)
library(ibd)
library(rstatix)
``` 
```{r, include = TRUE}
r_packages <- installed.packages()[names(sessionInfo()$otherPkgs), "Version"]

r_packages_df <- as.data.frame(r_packages)

colnames(r_packages_df) <- c("Version")

kable(r_packages_df)
```

get data in right format, one column per well, one time column and one blank column. 

```{r, include = FALSE}
# set wd
setwd("~/Documents/phd/DEG_yeast_insecticide_expt/senstivity_test/insecticides_sens/")
# read csv
insect_sens <- read.csv(file = "./results/form_comp_corr_blank_cont.csv", header = FALSE, stringsAsFactors = FALSE)

sens_data_form <- function(sens_data) {
  # transpose
  sens_data_trans <- t(sens_data)
  # save first row as colnames
  colnames(sens_data_trans) <- sens_data_trans [1, ]
  # delete first row, which is now duplicate of colnames
  sens_data_colnames <- sens_data_trans [-1, ]
  # remove any empty rows. Sometimes created when importing csv file 
  sens_data_no_blanks <- sens_data_colnames[rowSums(is.na(sens_data_colnames)) != ncol(sens_data_colnames),]
  # convert matrix into dataframe
  sens_data_df <- as.data.frame(sens_data_no_blanks)
  # convert everything to numeric
  sens_data_df[] <- lapply(sens_data_df, function(x) {
    if(is.factor(x)) as.numeric(as.character(x)) else x
  })
  # convert to data frame
  sens_data_corr <- as.data.frame(sens_data_df)
}

sens_data_corr <- sens_data_form(insect_sens)

# set any negative values to 0
sens_data_corr[sens_data_corr<0] <- 0
```

```{r}
# useful command for filtering column contents
# gc_out_filtered <- gc_out %>% filter(note != "cannot fit data") 
```

Now the data is in the right format use Growthcurver. To retrieve r_se and r_p as well as the other summary information columns have to be looped through individually.

```{r, message = FALSE, fig.width = 7}
# Let's create an output data frame to store the results in. 
# We'll create it so that it is the right size (it's faster this way!), 
# but leave it empty.
num_analyses <- length(names(sens_data_corr)) - 1
d_gc <- data.frame(sample = character(num_analyses),
                   k = numeric(num_analyses),
                   n0  = numeric(num_analyses),
                   r = numeric(num_analyses),
                   r_se = numeric(num_analyses),
                   r_p = numeric(num_analyses),
                   t_mid = numeric(num_analyses),
                   t_gen = numeric(num_analyses),
                   auc_l = numeric(num_analyses),
                   auc_e = numeric(num_analyses),
                   sigma = numeric(num_analyses),
                   stringsAsFactors = FALSE)

# Now, loop through all of the columns in the data frame. For each column,
# run Growthcurver, save the most useful metrics in the output data frame,
# and make a plot of all the growth curve data and their best fits.

par(mfcol = c(8,12))
par(mar = c(0.25,0.25,0.25,0.25))
y_lim_max <- max(sens_data_corr[,setdiff(names(sens_data_corr), "time")]) - min(sens_data_corr[,setdiff(names(sens_data_corr), "time")])

n <- 1    # keeps track of the current row in the output data frame
for (col_name in names(sens_data_corr)) {
  
  # Don't process the column called "time". 
  # It contains time and not absorbance data.
  if (col_name != "time") {

    # Create a temporary data frame that contains just the time and current col
    sens_data_corr_loop <- sens_data_corr[, c("time", col_name)]
    
    # Now, call Growthcurver to calculate the metrics using SummarizeGrowth
    gc_fit <- SummarizeGrowth(data_t = sens_data_corr_loop[, "time"], 
                              data_n = sens_data_corr_loop[, col_name],
                              bg_correct = "none")
    
    # Now, add the metrics from this column to the next row (n) in the 
    # output data frame, and increment the row counter (n)
    d_gc$sample[n] <- col_name
    d_gc[n, 2:11] <- c(gc_fit$vals$k,
                      gc_fit$vals$n0,
                      gc_fit$vals$r,
                      gc_fit$vals$r_se,
                      gc_fit$vals$r_p,
                      gc_fit$vals$t_mid,
                      gc_fit$vals$t_gen,
                      gc_fit$vals$auc_l,
                      gc_fit$vals$auc_e,
                      gc_fit$vals$sigma)
    n <- n + 1
    
    # Finally, plot the raw data and the fitted curve
    n_obs <- length(gc_fit$data$t)
    plot(gc_fit$data$t, gc_fit$data$N, 
         pch = 20, 
         xlim = c(0, 960), 
         ylim = c(0, y_lim_max),
         cex = 0.6, xaxt = "n", yaxt = "n")
    text(x = 960 / 2, y = y_lim_max, labels = col_name, pos = 1)
    lines(gc_fit$data$t, predict(gc_fit$model),col = "red")
  }
}

# Uncomment the next line to save the plots from your 96-well plate to a file
# dev.off()
```

Sigma values represent the residual sum of squares from the fit of the logistic curve to the data, so larger values mean poorer fits.

```{R, eval = TRUE, message = FALSE}
d_gc <- as_data_frame(d_gc)

# Plot a histogram of the sigma values in order to check for outliers
hist(d_gc$sigma, main = "Histogram of sigma values", xlab = "sigma")

```

Are my outliers high insecticide concentrations? Cypermethrin-5 had solubility issues, which resulted in the curve starting with artificially high OD readings. 7/8 Cypermethrin-5 are in the top 50 sigma scores. Not really surprising. 

``` {R, eval = FALSE, message = FALSE}
# Show the top 50 samples with the largest sigma value 
# (with the worst model fit to the growth curve data)
high_sigma <- d_gc %>% top_n(50, sigma) %>% arrange(desc(sigma))

high_sigma 
```

One additional method for identifying outlier parameters is to conduct a principal components analysis on the samples, which projects high dimensional data on lower dimensional space. Plotting the samples on the first two principal components (PC1 and PC2) can identify natural clusters within the growth curve data as well as outliers.

```{R, eval = TRUE, message = FALSE}
pca_gc_out <- as_data_frame(d_gc) 

# Prepare the gc_out data for the PCA
rownames(pca_gc_out) <- pca_gc_out$sample

# Do the PCA
pca.res <- prcomp(pca_gc_out %>% select(k:sigma), center=TRUE, scale=TRUE)

# Plot the results
as_data_frame(list(PC1=pca.res$x[,1],
                   PC2=pca.res$x[,2],
                   samples = rownames(pca_gc_out))) %>% 
  ggplot(aes(x=PC1,y=PC2, label=samples)) + 
  geom_text(size = 2)
```

When looking at the graph for thiacloprid-5-4 it is apparent it is an outlier.  

```{r}
# useful command for filtering column contents
# gc_out_filtered <- gc_out %>% filter(note != "cannot fit data") 

# save a complete version of the data with all the outliers
growthcurver_data <- d_gc
```

Need to remove outliers through a combination of PCA, sigma values and visual inspection of plots. Removed chlorpyrifos-0.1-7, tefluthrin-0.1-7, control-5-7 (when I knocked the plate and droplet went on lid) and cypermethrin-5-3, thiacloprid-5-4, thiacloprid-5-5. 

All the cypermethrin-5 are wrong as well but going to ignore that for now. 

"cypermethrin-5-1", "cypermethrin-5-2", "cypermethrin-5-3", "cypermethrin-5-4", "cypermethrin-5-5", "cypermethrin-5-6", "cypermethrin-5-7", "cypermethrin-5-8"

Also a control is an anomaly but we need it for the ANCOVA so keep it for now

```{r}
# put control back into anomalies to see effect , "control-5-7"
anomalies <- c("chlorpyrifos-0.1-7", "tefluthrin-0.1-7", "thiacloprid-5-4", "thiacloprid-5-5")

for (names in anomalies) {
  
  d_gc <- d_gc %>% filter(sample != names)
  
}

```

Then, take AUC and r for remaining wells and calculate averages for each condition over the remaining replicates. How to incorporate standard error for individual r values in average r values? 

```{r}
conditions_separately <- list()
conditions_stats <- tibble()

conditions <- c("control-", "acetamiprid-0.001", "acetamiprid-0.01", "acetamiprid-0.1", "acetamiprid-1","acetamiprid-5", "chlorpyrifos-0.001", "chlorpyrifos-0.01", "chlorpyrifos-0.1", "chlorpyrifos-1","chlorpyrifos-5", "clothianidin-0.001", "clothianidin-0.01", "clothianidin-0.1", "clothianidin-1","clothianidin-5", "cypermethrin-0.001", "cypermethrin-0.01", "cypermethrin-0.1", "cypermethrin-1", "cypermethrin-5", "flupyradifurone-0.001", "flupyradifurone-0.01", "flupyradifurone-0.1", "flupyradifurone-1","flupyradifurone-5", "imidacloprid-0.001", "imidacloprid-0.01", "imidacloprid-0.1", "imidacloprid-1","imidacloprid-5", "malathion-0.001", "malathion-0.01", "malathion-0.1", "malathion-1", "malathion-5", "sulfoxaflor-0.001", "sulfoxaflor-0.01", "sulfoxaflor-0.1", "sulfoxaflor-1", "sulfoxaflor-5", "tefluthrin-0.001", "tefluthrin-0.01", "tefluthrin-0.1", "tefluthrin-1", "tefluthrin-5", "thiacloprid-0.001", "thiacloprid-0.01", "thiacloprid-0.1", "thiacloprid-1", "thiacloprid-5")

for (name in 1:length(conditions)) {
  
  conditions_grouped <- d_gc %>% filter(str_detect(sample, conditions[name]))
  
  conditions_separately [name] <- conditions_grouped [ ,9]
  
  names(conditions_separately) [name] <- conditions[name]
  
  summ_stat <- stat.desc(conditions_separately[[name]])
  
  conditions_stats [name, 1] <- conditions[name]
  
  for (i in 1:length(summ_stat)) {
    
    conditions_stats [name, i+1] <- summ_stat [i]
    
  }
  
}

colnames(conditions_stats) <- c("condition", "nbr.val", "nbr.null", "nbr.na", "min", "max", "range", "sum", "median", "mean", "SE.mean", "CI.mean.0.95", "var", "std.dev", "coef.var")

```

Then plot this onto a dose response curve (semi logarithmic). Is there any effect? Does r and AUC decrease with increasing pesticide concentration? Or no effect? Or unexpected effect, which might suggest incorrect experimental design (inaccurate initial cell number, solubility of cypermethrin, not all in mid-log phase growth at the beginning)

```{r}
# pull out condition AUC mean and AUC mean CI 95%
rel_conditions_stats <- conditions_stats [ , c(1, 10, 12)]

# separate each insecticide
insecticide_names <- c("acetamiprid", "chlorpyrifos", "clothianidin", "cypermethrin", "flupyradifurone", "imidacloprid", "malathion", "sulfoxaflor", "tefluthrin", "thiacloprid")

insecticide_list <- list()

for (name in 1:length(insecticide_names)) {

  insecticide_pattern <- paste0(insecticide_names[name], "-\\d*", sep = "")
  
  insecticide_x <- rel_conditions_stats %>% filter(str_detect(condition, insecticide_pattern))

  insecticide_list [[name]]  <- insecticide_x
  
  names(insecticide_list) [[name]] <- insecticide_names[name]
}

insecticide_list_1 <- list()

concentration <- c(0.001, 0.01, 0.1, 1, 5)

for (insecticide in 1:length(insecticide_list)) {
  
   insecticide_concs <- cbind(insecticide_list [[insecticide]], concentration)
  
   insecticide_list_1 [[insecticide]]  <- insecticide_concs
   
   names(insecticide_list_1) [[insecticide]] <- insecticide_names[insecticide]

}

# top sulfoxaflor concentration was 2.5 not 5
insecticide_list_1[[8]][5,4] <- as.numeric(gsub(5, 2.5, insecticide_list_1[[8]][5,4]))
```

```{r}
  # make control row
  control_stats <- rel_conditions_stats %>% filter(str_detect(condition, "control"))
  control_conc <- 0.0001
  control_row <- cbind(control_stats, control_conc)
  colnames(control_row) <- colnames(insecticide_list_1[[1]])
  
  # bind it to the other insecticide dataframes
  insecticide_list_2 <- list()

for (insecticide in 1:length(insecticide_list_1)) {
  
   insecticide_control <- rbind(insecticide_list_1 [[insecticide]], control_row)
  
   insecticide_list_2 [[insecticide]]  <- insecticide_control
   
   names(insecticide_list_2) [[insecticide]] <- insecticide_names[insecticide]

}
```

```{r}
require(scales)

plot_list <- list()

for (insecticide in 1:length(insecticide_list_2)) {
  
  title <- paste0(names(insecticide_list_2[insecticide]), " dose-response curve", sep = "" )
  
  df <- insecticide_list_2[[insecticide]]

  df$facet <- ifelse(df$concentration == min(df$concentration), 1, 2)
  
  drc <- ggplot(df, aes(x=concentration,y=mean)) +
    geom_point(data = subset(df, facet == 1)) +
    geom_point(data = subset(df, facet == 2)) +
    scale_x_log10(breaks = c(0.0001, 10^(-3:10)), 
                labels = c(0, math_format()(-3:10))) +
    geom_errorbar(aes(ymin=mean-CI.mean.0.95, ymax=mean+CI.mean.0.95), width=.1) + 
    ylim(0, NA) +
    ggtitle(title) +
    labs(x="Concentration (log scale)", y="AUC",size=1) +
    facet_grid(~facet, scales = 'free', space = 'free') +
    theme(panel.background = element_rect(fill = "white"), plot.margin = margin(1, 1, 1, 1, "cm"),
    axis.line = element_line(), strip.text.x = element_blank(), plot.background = element_rect(
      fill = "grey90",
      colour = "black",
      size = 1
  )
  )
  
  plot_list [[insecticide]] <- drc

}

plot_list

```

Best option is to have three independent variables: concentration (continuous independent), pesticide (categorical independent) and day (categorical independent) and one dependent variable: AUC (continuous dependent). AUC = concentation + pesticide + day + (pesticide x concentration) (interaction) + (day x concentration) (interaction).  pesticide x concentration interaction is the interesting term. As I have at least one continuous independent variable and one categorical independent variable I can perform an ANCOVA. 

```{r}
# create a column for the day (categorical independent variable)
sample_a <- d_gc [ , c(1,9)]

days <- c("one", "two", "three", "four", "five", "six", "seven", "eight")

sample_au <-  tibble()

for (day in 1:length(days)) {
  
  day_pattern <- paste0("\\w*-.*-", day, sep = "")
  
  day_x <- sample_a %>% filter(str_detect(sample, day_pattern))
  
  day_x$day <- days [day]
  
 sample_au <- rbind(sample_au, day_x)
}

# create a column for the insecticide and control (categorical independent variable)
insecticide_control_name <- c(insecticide_names, "control")

sample_auc <-  tibble()

for (insecticide in 1:length(insecticide_control_name)) {
  
  by_insecticide <- sample_au %>% filter(str_detect(sample, insecticide_control_name [insecticide]))
  
  by_insecticide$insecticide <- insecticide_control_name [insecticide]
  
  sample_auc <- rbind(sample_auc, by_insecticide)

}

# give controls same name
names <- sample_auc$sample

sample_auc_control <- str_replace_all(names, "control-.*-\\d$", "control")

sample_auc [ , 1] <- sample_auc_control

# create a column for the concentration, add controls separately (continuous independent variable)
sample_aucl <- tibble()

for (conc in 1:length(concentration)) {
  
  indiv_conc <- paste0("\\w*-", concentration [conc], "-", sep = "")
  
  by_concentration <- sample_auc %>% filter(str_detect(sample, indiv_conc))
  
  by_concentration$concentration <- concentration [conc]
  
  sample_aucl <- rbind(sample_aucl, by_concentration)
  
}

controls_sep <- sample_auc %>% filter(str_detect(sample, "control"))

controls_sep$concentration <- 0

sample_aucl <- rbind(sample_aucl, controls_sep)

# give replicates same name for each group.
names <- sample_aucl$sample

sample_aucl_control <- str_replace_all(names, "control-.*-\\d$", "control")

sample_aucl [ , 1] <- sample_aucl_control

replicate_name <- sample_aucl$sample

replicate_same_names <- tibble()

for (name in 1:length(replicate_name)) {
  
  same_name <- str_replace_all(sample_aucl [name, 1], "-\\d$", "")

  replicate_same_names [name, 1] <- same_name
    
}

sample_aucl [, 1] <- replicate_same_names 
```

If I want to look at the insecticides one by one the below code is useful for splitting the dataset accordingly.

```{r}
# separate replicates for each insecticide with the control
insecticide_names <- c("acetamiprid", "chlorpyrifos", "clothianidin", "cypermethrin", "flupyradifurone", "imidacloprid", "malathion", "sulfoxaflor", "tefluthrin", "thiacloprid")

# make control rows
controls <- sample_aucl %>% filter(str_detect(sample, "control"))

replicate_insect_control <- list()

for (name in 1:length(insecticide_names)){
  
  insecticide_x <- sample_aucl %>% filter(str_detect(sample, insecticide_names[name]))
  
  insecticide_x_control <- rbind(insecticide_x, controls)

  replicate_insect_control [[name]]  <- insecticide_x_control
  
  names(replicate_insect_control) [[name]] <- insecticide_names[name]

}

# convert character names into corresponding numerical concentrations for each insecticide. Obviously need to try and loop this.
replicate_insect_control$acetamiprid$sample <- str_replace_all(replicate_insect_control$acetamiprid$sample, "control", "0") %>% str_replace_all("\\w*-", "") %>% as.numeric()
replicate_insect_control$chlorpyrifos$sample <- str_replace_all(replicate_insect_control$chlorpyrifos$sample, "control", "0") %>% str_replace_all("\\w*-", "") %>% as.numeric()
replicate_insect_control$clothianidin$sample <- str_replace_all(replicate_insect_control$clothianidin$sample, "control", "0") %>% str_replace_all("\\w*-", "") %>% as.numeric()
replicate_insect_control$cypermethrin$sample <- str_replace_all(replicate_insect_control$cypermethrin$sample, "control", "0") %>% str_replace_all("\\w*-", "") %>% as.numeric()
replicate_insect_control$flupyradifurone$sample <- str_replace_all(replicate_insect_control$flupyradifurone$sample, "control", "0") %>% str_replace_all("\\w*-", "") %>% as.numeric()
replicate_insect_control$imidacloprid$sample <- str_replace_all(replicate_insect_control$imidacloprid$sample, "control", "0") %>% str_replace_all("\\w*-", "") %>% as.numeric()
replicate_insect_control$malathion$sample <- str_replace_all(replicate_insect_control$malathion$sample, "control", "0") %>% str_replace_all("\\w*-", "") %>% as.numeric()
replicate_insect_control$sulfoxaflor$sample <- str_replace_all(replicate_insect_control$sulfoxaflor$sample, "control", "0") %>% str_replace_all("\\w*-", "") %>% as.numeric()
replicate_insect_control$tefluthrin$sample <- str_replace_all(replicate_insect_control$tefluthrin$sample, "control", "0") %>% str_replace_all("\\w*-", "") %>% as.numeric()
replicate_insect_control$thiacloprid$sample <- str_replace_all(replicate_insect_control$thiacloprid$sample, "control", "0") %>% str_replace_all("\\w*-", "") %>% as.numeric()
```

Look at the variation by day. This variation was probably introduced by yeast cells not all being in mid-log phase growth, or variation in initial yeast cell number added to each well. 

```{r}

sample_aucl <- sample_aucl %>%
  reorder_levels(day, order = c("one", "two", "three", "four", "five", "six", "seven", "eight"))

boxplot(auc_l ~ day, data = sample_aucl)
```

Before going any further I am going to remove cypermethrin and sulfoxaflor from the dataset. The solubility of cypermethrin inflated the optical density measurements and sulfoxaflor only had 5 replicates, all of which with unknown sulfoxaflor concentrations due to evaporation. 

```{r}
no_cyper_sulfox <- sample_aucl[c(-grep("cypermethrin", sample_aucl$insecticide),-grep("sulfoxaflor", sample_aucl$insecticide)), ]
```

I need to evenly distribute 40 controls amongst 8 insecticides so that the day effect will be minimised. This requires balanced incomplete block design. In my case I have 8 days (treatments in the examples, g), 8 blocks (insecticides, b), 5 days a block (k) and 5 replicates (r). In this case a BIBD doesn't exist because for 

r.(k-1) = λ.(g-1)

λ isn't a whole number. 

There is, however, an incomplete block design. The first output shows the block design and the second is a concurrence matrix and shows how many times any pair of treatments appears together in the same block. 
 
```{r}
bibd <- ibd(v = 8, b = 8, k = 5)

bibd$design

#bibd$conc.mat
```

following the block design above I need to allocate the controls to the insecticides. Remember the use of grep here. As I searched a specific column grep returned a row index, which can they be fed into normal subsetting via indexing. 

```{r}
only_controls <- no_cyper_sulfox[grep("control", no_cyper_sulfox$insecticide), ]

insecticide_names <- c("acetamiprid", "chlorpyrifos", "clothianidin", "flupyradifurone", "imidacloprid", "malathion", "tefluthrin", "thiacloprid")

# if i remove control again remember to change rep(7, each = 5) to rep(7, each = 4)
only_controls$day_numerical <- c(rep(c(1:6), each = 5), rep(7, each = 5), rep(8, each = 5))

ancova_df <- no_cyper_sulfox[-grep("control", no_cyper_sulfox$insecticide), ]

# if you run this twice it empties insecticide_names so be careful
# insecticide_names <- insecticide_names [c(-grep("cypermethrin", insecticide_names), -grep("sulfoxaflor", insecticide_names))]

for (insecticide in 1:length(insecticide_names)) {
  
  ibd_row <- bibd$design [insecticide, ]

  four_controls <- tibble()

  for (day in 1:length(ibd_row)) {
  
    ibd_day <- only_controls[grep(ibd_row [day], only_controls$day_numerical), ]
  
    random_control <- ibd_day[sample(nrow(ibd_day), 1), ]
  
    only_controls <- setdiff(only_controls, random_control)
  
    four_controls <- rbind(four_controls, random_control)
  
}

  four_controls$insecticide <- gsub("control", insecticide_names [insecticide], four_controls$insecticide)

  ancova_df <- rbind(ancova_df, four_controls [ ,1:5])

}
```

Remember that when you run the chunk above you randomly assign the controls to the insecticides again according to the IBD. See if doing this varies the results. Would show the control assignment does have an effect. Could do because I'm using an incomplete block design.

What are the assumptions of linear regression?

First, build a simpler linear model:

AUC = insecticide + concentration + (insecticide * concentration)

The interesting part of the model is the interaction between insecticide and concentration.

```{r}
model_1 <- lm(auc_l ~ insecticide + concentration + insecticide*concentration, data = ancova_df)

summary(model_1)
```

Add in day:

AUC = insecticide + concentration + day + (insecticide * concentration) 

```{r}
model_2 <- lm(auc_l ~ insecticide + concentration + day + insecticide*concentration, data = ancova_df)

summary(model_2)
```

These are the only two models that mean anything biologically. Insecticide and concentration only mean something when taken together. I'm not doing an ANCOVA because that is to test for significance between an independent categorical variables and dependent continuous variables, controlling for an independent continuous variable. I am not controlling for this variable. Rather I am interested in the interaction between the one independent categorical variable (insecticide) and the independent continuous variable (concentration) and if that interaction is significantly association with the response variable. 

```{r}
library(ggpubr)
library(rstatix)
library(broom)

# Fit the model, the covariate goes first
model_2 <- lm(auc_l ~ insecticide + concentration + day + insecticide*concentration, data = ancova_df)
# Inspect the model diagnostic metrics
model.metrics <- augment(model_2) %>%
  select(-.hat, -.sigma, -.fitted) # Remove details

shapiro_test(model.metrics$.resid)
```

My residuals aren't normally distributed. Violates assumption of linear regression. Have to transform my data in some manner. Plot the residuals to get an idea of their distribution and the transformation necessary. 

Plot residuals of model 2

```{r}
hist(model_2$residuals)
plot(density(model_2$residuals))
```

Before that, plot individual replicates by day for each insecticide with a line connecting them. Sample with replacement for controls so all 8 insecticides can be visualised. Have to start with d_gc_complete because require previously filtered anomalies. Create a formatting function. 

```{r}

aucl_formatting_function <- function(growthcurver_data) {
  
  # subset from growthcurver_data the two required columns
  sample_area <- growthcurver_data [, c(1, 9)]
  
  # remove sulfoxaflor and cypermethrin
  sample_area <- sample_area [-grep(pattern = "(cypermethrin|sulfoxaflor)", x = sample_area$sample), ]
  
  # add insecticide column to sample_area
  
  # create vector with remaining insecticides
  eight_insecticides <- c("acetamiprid", "chlorpyrifos", "clothianidin", "flupyradifurone", "imidacloprid", "malathion", "tefluthrin", "thiacloprid", "control")
  
  # create a df to save loop output in 
  sample_area_insecticide <- tibble()
  
  # extract individual insecticides, add insecticide column and recombine
  for (insecticide in 1:length(eight_insecticides)) {
    
    insecticide_alone <-  sample_area [grep(pattern = eight_insecticides [insecticide], x = sample_area$sample), ]
    
    insecticide_alone$insecticide <- eight_insecticides [insecticide]
    
    sample_area_insecticide <- rbind(sample_area_insecticide, insecticide_alone)
    
  }
  
  # add day to sample_area_insecticide
  
  # create day
  days <- c("one", "two", "three", "four", "five", "six", "seven", "eight")
  
  # create a df to save loop output in 
  sample_area_insecticide_day <- tibble()
  
  # extract individuals days, add day column and combine
  for (day in 1:length(days)) {
    
    day_pattern <- paste(".+-", day, "$", sep = "")
    
    day_alone <- sample_area_insecticide [grep(pattern = day_pattern, x = sample_area_insecticide$sample), ]
    
    day_alone$day <- days [day]
    
    sample_area_insecticide_day <- rbind(sample_area_insecticide_day, day_alone)
    
  }
  
  # add concentration to sample_area_insecticide_day
  
  # create concentration vector
  concentration_vector <- c(0.001, 0.01, 0.1, 1, 5)
  
  # create a df to save loop output in 
  sample_area_insecticide_day_concentration <- tibble()
  
  # extract individuals concentrations, add concentrations column and combine
  for (concentration in 1:length(concentration_vector)) {
    
    concentration_pattern <- paste(".+-", concentration_vector [concentration], "-.", sep = "")
    
    concentration_alone <- sample_area_insecticide_day [grep(pattern = concentration_pattern, x = sample_area_insecticide_day$sample), ]
    
    concentration_alone$concentration <- concentration_vector [concentration]
    
    sample_area_insecticide_day_concentration <- rbind(sample_area_insecticide_day_concentration, concentration_alone)
  }

  # extract controls
  controls_alone <- sample_area_insecticide_day_concentration [grep(pattern = "control", x = sample_area_insecticide_day_concentration$sample), ]
  
  # set correct sample name
  controls_alone$sample <- "control"
  
  # set correct concentration (for making graphs)
  controls_alone$concentration <- 0.0001
  
  # remove control rows from sample_area_insecticide_day_concentration
  sample_area_insecticide_day_concentration <- sample_area_insecticide_day_concentration [-grep(pattern = "control", x = sample_area_insecticide_day_concentration$sample), ]
  
  # add new control rows to sample_area_insecticide_day_concentration
  formatted_growthcurver_df <- rbind(sample_area_insecticide_day_concentration, controls_alone)
  
  return(formatted_growthcurver_df)

}

formatted_growthcurver_df <- aucl_formatting_function(growthcurver_data)

```

Using this formatted df create plots of individual replicates for each insecticide. Assign controls randomly to insecticide by day with replacement. 

```{r}

insecticides_assigned_controls <- function(formatted_growthcurver_df) {
  
  # separate controls
  controls_alone <- formatted_growthcurver_df [grep(pattern = "control" , x = formatted_growthcurver_df$sample), ]

  # split controls into a list by day

  # create day
  days <- c("one", "two", "three", "four", "five", "six", "seven", "eight")
  
  # create day list
  control_day_list <- list()
  
  for (day in 1:length(days)) {
      
      control_by_day <- controls_alone [grep(pattern = days [day], x = controls_alone$day), ]
      
      control_day_list [[day]] <- control_by_day
      
  }
  
  # for each insecticide assign a random control from each day
  
  # create vector with remaining insecticides
  eight_insecticides <- c("acetamiprid", "chlorpyrifos", "clothianidin", "flupyradifurone", "imidacloprid", "malathion", "tefluthrin", "thiacloprid")
  
  # create empty df to store new data in
  controls_labelled_zero_insecticide <- tibble()
  
  for (insecticide in 1:length(eight_insecticides)) {
    
    insecticide_alone <-  formatted_growthcurver_df [grep(pattern = eight_insecticides [insecticide], x = formatted_growthcurver_df$sample), ]
    
    # create dataframe to save eight random controls, one from each day, in
    eight_random_controls <- tibble() 
    
    for (day in 1:length(days)) {
      
      random_control <- control_day_list [[day]] [sample(nrow(control_day_list [[day]]), 1, replace = TRUE, prob = NULL), ]
      
      eight_random_controls <- rbind(eight_random_controls, random_control)
    }
    
    eight_random_controls$insecticide <-  eight_insecticides [insecticide]
    
    insecticide_and_controls <- rbind(insecticide_alone, eight_random_controls)
    
    controls_labelled_zero_insecticide <- rbind(controls_labelled_zero_insecticide, insecticide_and_controls)
    
  }
  
  return(controls_labelled_zero_insecticide)
}

assigned_controls_df <- insecticides_assigned_controls(formatted_growthcurver_df)

```

Use assigned_controls_df to plot replicate by day for each insecticide. Recycle plot code from above where possible

```{r}
line_plot_list_function <- function(assigned_controls_df) {
  
  # split assigned_controls_df into 8 lists by insecticide. Also split each insecticide by day. 

  # define 8 insecticides
  eight_insecticides <- c("acetamiprid", "chlorpyrifos", "clothianidin", "flupyradifurone", "imidacloprid", "malathion", "tefluthrin", "thiacloprid")
  
  # create list to save loop output
  insecticide_list <- list()
  
  # split insecticides into their own dfs within a list
  for (insecticide in 1:length(eight_insecticides)) {
    
    insecticide_alone <- assigned_controls_df [grep(pattern = eight_insecticides [insecticide], x = assigned_controls_df$insecticide), ]
    
    # create days vector
    days <- c("one", "two", "three", "four", "five", "six", "seven", "eight")
    
    # create new list to save by day dfs
    insecticide_by_day_list <- list()
    
    for (day in 1:length(days)) {
      
      by_day <- insecticide_alone [grep(pattern = days [day], x = insecticide_alone$day), ]
      
      insecticide_by_day_list [[day]] <- by_day
      
      names(insecticide_by_day_list) [[day]] <- days [day]
      
    }
    
    insecticide_list [[insecticide]] <- insecticide_by_day_list
    
    names(insecticide_list) [[insecticide]] <- eight_insecticides [insecticide]
  }
  
  return(insecticide_list)
  
}

line_plot_list <- line_plot_list_function(assigned_controls_df)
```

Think I got a bit loop happy above but don't delete yet as may be useful. 

```{r}
by_insecticide_df_function <- function(assigned_controls_df) {
  
  # split assigned_controls_df into 8 lists by insecticide. Also split each insecticide by day. 

  # define 8 insecticides
  eight_insecticides <- c("acetamiprid", "chlorpyrifos", "clothianidin", "flupyradifurone", "imidacloprid", "malathion", "tefluthrin", "thiacloprid")
  
  # create list to save loop output
  insecticide_list <- list()
  
  # split insecticides into their own dfs within a list
  for (insecticide in 1:length(eight_insecticides)) {
    
    insecticide_alone <- assigned_controls_df [grep(pattern = eight_insecticides [insecticide], x = assigned_controls_df$insecticide), ]
    
    insecticide_list [[insecticide]] <- insecticide_alone
    
    names(insecticide_list) [[insecticide]] <- eight_insecticides[insecticide]
    
  }
  
  return(insecticide_list)
  
}

by_insecticide_dfs <- by_insecticide_df_function(assigned_controls_df)

```



```{r}
require(scales)

plot_list <- list()

for (insecticide in 1:length(by_insecticide_dfs)) {
  
  title <- paste0(names(by_insecticide_dfs[insecticide]), " dose-response curve", sep = "" )
  
  df <- by_insecticide_dfs[[insecticide]]

  df$facet <- ifelse(df$concentration == min(df$concentration), 1, 2)
  
  drc <- ggplot(df, aes(x=concentration,y=auc_l, color=day)) +
    geom_point(data = subset(df, facet == 1)) +
    geom_point(data = subset(df, facet == 2)) +
    geom_line() +
    scale_x_log10(breaks = c(0.0001, 10^(-3:10)), 
                labels = c(0, math_format()(-3:10))) +
    ylim(0, NA) +
    ggtitle(title) +
    labs(x="Concentration (log scale)", y="AUC",size=1) +
    facet_grid(~facet, scales = 'free', space = 'free') +
    theme(panel.background = element_rect(fill = "white"), plot.margin = margin(1, 1, 1, 1, "cm"),
    axis.line = element_line(), strip.text.x = element_blank(), plot.background = element_rect(
      fill = "grey90",
      colour = "black",
      size = 1
  )
  )
  
  plot_list [[insecticide]] <- drc

}

plot_list

```

Above I can introduce the axis break but not line connecting all points. Below I can connect all points but not have axis break. 

```{r}
require(scales)

plot_list <- list()

for (insecticide in 1:length(by_insecticide_dfs)) {
  
  title <- paste0(names(by_insecticide_dfs[insecticide]), " dose-response curve", sep = "" )
  
  df <- by_insecticide_dfs[[insecticide]]

  drc <- ggplot(df, aes(x=concentration,y=auc_l, color=day)) +
    geom_point() +
    geom_line() +
    scale_x_log10(breaks = c(0.0001, 10^(-3:10)), 
                labels = c(0, math_format()(-3:10))) +
    ylim(0, NA) +
    ggtitle(title) +
    labs(x="Concentration (log scale)", y="AUC",size=1) +
    theme(panel.background = element_rect(fill = "white"), plot.margin = margin(1, 1, 1, 1, "cm"),
    axis.line = element_line(), strip.text.x = element_blank(), plot.background = element_rect(
      fill = "grey90",
      colour = "black",
      size = 1
  )
  )
  
  plot_list [[insecticide]] <- drc

}

plot_list

# multiplot(plot_list [[1]], plot_list [[2]], plot_list [[3]], plot_list [[4]], plot_list [[5]], plot_list [[6]], plot_list [[7]], plot_list [[8]], cols=4)

```

```{r}
# Multiple plot function
#
# ggplot objects can be passed in ..., or to plotlist (as a list of ggplot objects)
# - cols:   Number of columns in layout
# - layout: A matrix specifying the layout. If present, 'cols' is ignored.
#
# If the layout is something like matrix(c(1,2,3,3), nrow=2, byrow=TRUE),
# then plot 1 will go in the upper left, 2 will go in the upper right, and
# 3 will go all the way across the bottom.
#
multiplot <- function(..., plotlist=NULL, file, cols=1, layout=NULL) {
  library(grid)

  # Make a list from the ... arguments and plotlist
  plots <- c(list(...), plotlist)

  numPlots = length(plots)

  # If layout is NULL, then use 'cols' to determine layout
  if (is.null(layout)) {
    # Make the panel
    # ncol: Number of columns of plots
    # nrow: Number of rows needed, calculated from # of cols
    layout <- matrix(seq(1, cols * ceiling(numPlots/cols)),
                    ncol = cols, nrow = ceiling(numPlots/cols))
  }

 if (numPlots==1) {
    print(plots[[1]])

  } else {
    # Set up the page
    grid.newpage()
    pushViewport(viewport(layout = grid.layout(nrow(layout), ncol(layout))))

    # Make each plot, in the correct location
    for (i in 1:numPlots) {
      # Get the i,j matrix positions of the regions that contain this subplot
      matchidx <- as.data.frame(which(layout == i, arr.ind = TRUE))

      print(plots[[i]], vp = viewport(layout.pos.row = matchidx$row,
                                      layout.pos.col = matchidx$col))
    }
  }
}
```












Below use as the basis for a mixed model for the whole dataset if I end up doing one. Not sure as data is normally distributed.

Separately look at Thiacloprid alone:

lmer(auc_l ~ concentration + (1|day), data = thiacloprid_controls)

Separate just Thiacloprid and all controls. Then, try a mixed model on this dataset.

```{r}
controls1 <- sample_aucl [grep("^0$", sample_aucl$concentration), ]

thiacloprid <- sample_aucl [grep("thiacloprid", sample_aucl$insecticide), ]

thiacloprid_controls <- rbind(controls1, thiacloprid)

library(lme4)

mixed.thiacloprid <- lmer(auc_l ~ concentration + (1|day), data = thiacloprid_controls)

summary(mixed.thiacloprid)
```