---
title: "insecticides_growthcurver_1"
author: "Guy Mercer"
date: "02/10/2020"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE, message = FALSE, warning = FALSE)
```

Machine Settings:

* Number of Cycles - 192

* Cycle Length - 300s

* Wavelength - 600nm

* Temperature - 30°C

* Shake - Before Each Cycle (272s)

* Shake Mode - Double Orbital

* Shake Frequency - 200rpm

* Total Well Volume - 200µl

I combined all the replicates using zsh to output a formatted, compiled csv file called formatted_compiled. I then edited the names of controls and blanks.

```{zsh raw-file-formatting}
#!/usr/bin/env zsh

# setwd
cd /Users/guy/Documents/phd/DEG_yeast_insecticide_expt/senstivity_test/insecticides_sens

./WHATIDID.sh 
```

```{r}
library(tidyverse)
library(knitr)
library(growthcurver)
library(pastecs)
library(ibd)
library(rstatix)
library(ggpubr)
library(broom)
library(patchwork)
library(sjPlot)
library(sjmisc)
library(sjlabelled)
# library(fitdistrplus)
``` 

```{r}
# set wd
setwd("~/Documents/phd/DEG_yeast_insecticide_expt/senstivity_test/insecticides_sens/")

# read csv
insect_sens <- read.csv(file = "./results/form_comp_corr_blank_cont.csv", header = FALSE, stringsAsFactors = FALSE)

# formatting function
sens_data_form <- function(sens_data) {
  # transpose
  sens_data_trans <- t(sens_data)
  # save first row as colnames
  colnames(sens_data_trans) <- sens_data_trans [1, ]
  # delete first row, which is now duplicate of colnames
  sens_data_colnames <- sens_data_trans [-1, ]
  # remove any empty rows. Sometimes created when importing csv file 
  sens_data_no_blanks <- sens_data_colnames[rowSums(is.na(sens_data_colnames)) != ncol(sens_data_colnames),]
  # convert matrix into dataframe
  sens_data_df <- as.data.frame(sens_data_no_blanks)
  # convert everything to numeric
  sens_data_df[] <- lapply(sens_data_df, function(x) {
    if(is.factor(x)) as.numeric(as.character(x)) else x
  })
  # convert to data frame
  sens_data_corr <- as.data.frame(sens_data_df)
  
  return(sens_data_corr)
}

sens_data_corr <- sens_data_form(insect_sens)

# set any negative values to 0
sens_data_corr[sens_data_corr<0] <- 0
```

To input the data into Growthcurver I had to alter the formatting. When using Growthcurver, columns have to be looped through individually for a more detailed output. Growth curve data is fitted to the standard form of the logistic equation (sigmoidal). Displayed below are samples of interest. The first eight samples were technical anomalies. The last five were those with large residuals that had to be excluded to make the data lognormally distributed (discussed later). 

```{r, include = FALSE}
growthcurver_function <- function(sens_data_corr) {
  
# Let's create an output data frame to store the results in. 
# We'll create it so that it is the right size (it's faster this way!), 
# but leave it empty.
num_analyses <- length(names(sens_data_corr)) - 1
d_gc <- data.frame(sample = character(num_analyses),
                   k = numeric(num_analyses),
                   n0  = numeric(num_analyses),
                   r = numeric(num_analyses),
                   r_se = numeric(num_analyses),
                   r_p = numeric(num_analyses),
                   t_mid = numeric(num_analyses),
                   t_gen = numeric(num_analyses),
                   auc_l = numeric(num_analyses),
                   auc_e = numeric(num_analyses),
                   sigma = numeric(num_analyses),
                   stringsAsFactors = FALSE)

# Now, loop through all of the columns in the data frame. For each column,
# run Growthcurver, save the most useful metrics in the output data frame,
# and make a plot of all the growth curve data and their best fits.
par(mfcol = c(4,4))
par(mar = c(1,1,1,1))
y_lim_max <- max(sens_data_corr[,setdiff(names(sens_data_corr), "time")]) - min(sens_data_corr[,setdiff(names(sens_data_corr), "time")])

n <- 1    # keeps track of the current row in the output data frame
for (col_name in names(sens_data_corr)) {
  
  # Don't process the column called "time". 
  # It contains time and not absorbance data.
  if (col_name != "time") {
    
    # Create a temporary data frame that contains just the time and current col
    sens_data_corr_loop <- sens_data_corr[, c("time", col_name)]
    
    # Now, call Growthcurver to calculate the metrics using SummarizeGrowth
    gc_fit <- SummarizeGrowth(data_t = sens_data_corr_loop[, "time"], 
                              data_n = sens_data_corr_loop[, col_name],
                              bg_correct = "none")
    
    # Now, add the metrics from this column to the next row (n) in the 
    # output data frame, and increment the row counter (n)
    d_gc$sample[n] <- col_name
    d_gc[n, 2:11] <- c(gc_fit$vals$k,
                       gc_fit$vals$n0,
                       gc_fit$vals$r,
                       gc_fit$vals$r_se,
                       gc_fit$vals$r_p,
                       gc_fit$vals$t_mid,
                       gc_fit$vals$t_gen,
                       gc_fit$vals$auc_l,
                       gc_fit$vals$auc_e,
                       gc_fit$vals$sigma)
    n <- n + 1
    
    # Finally, plot the raw data and the fitted curve
    n_obs <- length(gc_fit$data$t)
    plot(gc_fit$data$t, gc_fit$data$N, 
         pch = 20, 
         xlim = c(0, 960), 
         ylim = c(0, y_lim_max),
         cex = 0.6, xaxt = "n", yaxt = "n")
    text(x = 960 / 2, y = y_lim_max, labels = col_name, pos = 1)
    lines(gc_fit$data$t, predict(gc_fit$model),col = "red")
  }
}

# Uncomment the next line to save the plots from your 96-well plate to a file
# dev.off()

return(d_gc)

}

d_gc <- growthcurver_function(sens_data_corr = sens_data_corr)
```

```{r}
replicates_of_interest <- c("time", "chlorpyrifos-0.1-7", "tefluthrin-0.1-7", "thiacloprid-5-4", "thiacloprid-5-5", "control-5-7", "thiacloprid-1-3", "control-1-8", "imidacloprid-0.01-8", "flupyradifurone-0.01-8", "thiacloprid-1-6")

replicates_of_interest_df <- tibble(matrix(nrow=nrow(sens_data_corr)))

for (sample in 1:length(replicates_of_interest)) {
  
  replicate_col <- sens_data_corr [ , grep(pattern = replicates_of_interest [sample], x = names(sens_data_corr))]
  
  replicates_of_interest_df [ , sample] <- replicate_col
  
}

colnames(replicates_of_interest_df) <- replicates_of_interest 

replicates_of_interest_ <- growthcurver_function(sens_data_corr = replicates_of_interest_df)

```

Sigma values represent the residual sum of squares from the fit of the logistic curve to the data, so larger values mean poorer fit to logistic model. Cypermethrin's solubility issues artificially increased its starting OD readings, leading to a poor model fit. 

```{r}
d_gc <- as_tibble(d_gc)

# Plot a histogram of the sigma values in order to check for outliers
hist(d_gc$sigma, main = "Histogram of sigma values", xlab = "sigma")

# Show the top 50 samples with the largest sigma value 
# (with the worst model fit to the growth curve data)
high_sigma <- d_gc %>% top_n(50, sigma) %>% arrange(desc(sigma))
```


One additional method for identifying outlier parameters is to conduct a principal components analysis on the samples, which projects high dimensional data on lower dimensional space. Plotting the samples on the first two principal components (PC1 and PC2) can identify natural clusters within the growth curve data as well as outliers.

```{r}
pca_gc_out <- as_tibble(d_gc) 

# Prepare the gc_out data for the PCA
rownames(pca_gc_out) <- pca_gc_out$sample

# Do the PCA
pca.res <- prcomp(pca_gc_out %>% select(k:sigma), center=TRUE, scale=TRUE)

# pdf(file="pca.pdf") if i want to save the plot
# Plot the results
as_tibble(list(PC1=pca.res$x[,1],
                   PC2=pca.res$x[,2],
                   samples = rownames(pca_gc_out))) %>% 
  ggplot(aes(x=PC1,y=PC2, label=samples)) + 
geom_text(size = 1)
# dev.off()
```

```{r}
# save a complete version of the data with all the outliers
growthcurver_data <- d_gc
```

Need to remove outliers through a combination of PCA, sigma values and visual inspection of plots. Samples are removed if they fit the following three criteria: not bound by PCA y = -4 and x = 5, sigma > 0.05 and obvious error from visual inspection of plots. There were also some possible pipetting anomalies, described separately below. 

```{r}
anomalies <- c("chlorpyrifos-0.1-7", "tefluthrin-0.1-7", "thiacloprid-5-4", "thiacloprid-5-5", "thiacloprid-1-3", "control-5-7")

for (sample in 1:length(anomalies)) {
  
  d_gc <-  d_gc [-grep(pattern = anomalies [sample], x = d_gc$sample), ]
  
}

pipetting_anomalies <- c("control-1-8", "imidacloprid-0.01-8", "flupyradifurone-0.01-8")

for (sample in 1:length(pipetting_anomalies)) {
  
  d_gc <-  d_gc [-grep(pattern = pipetting_anomalies [sample], x = d_gc$sample), ]
  
}
# I see no reason to remove this. If I do though it is the difference between failing and passing a shapiro wilks test once data is transformed. Thiacloprid significant both with and without
d_gc <-  d_gc [-grep(pattern = "thiacloprid-1-6", x = d_gc$sample), ]

```

Best option is to have three independent variables: concentration (continuous independent), insecticide (categorical independent) and day (categorical independent) and one dependent variable: AUC (continuous dependent). AUC = concentation + pesticide + day + (pesticide x concentration) (interaction).  pesticide x concentration interaction is the interesting term. To do this the data has to be reformatted so there are columns with concentration, day and insecticide. At this point sulfoxaflor and cypermethrin were removed due to evaporation and solubility issues respectively. 

```{r}
aucl_formatting_function <- function(growthcurver_data, aucl_or_r) {
  
  # subset from growthcurver_data the two required columns
  sample_area <- growthcurver_data [, c(1, aucl_or_r)]
  
  # remove sulfoxaflor and cypermethrin
  sample_area <- sample_area [-grep(pattern = "(cypermethrin|sulfoxaflor)", x = sample_area$sample), ]
  
  # add insecticide column to sample_area
  
  # create vector with remaining insecticides
  eight_insecticides <- c("acetamiprid", "chlorpyrifos", "clothianidin", "flupyradifurone", "imidacloprid", "malathion", "tefluthrin", "thiacloprid", "control")
  
  # create a df to save loop output in 
  sample_area_insecticide <- tibble()
  
  # extract individual insecticides, add insecticide column and recombine
  for (insecticide in 1:length(eight_insecticides)) {
    
    insecticide_alone <-  sample_area [grep(pattern = eight_insecticides [insecticide], x = sample_area$sample), ]
    
    insecticide_alone$insecticide <- eight_insecticides [insecticide]
    
    sample_area_insecticide <- rbind(sample_area_insecticide, insecticide_alone)
    
  }
  
  # add day to sample_area_insecticide
  
  # create day
  days <- c("one", "two", "three", "four", "five", "six", "seven", "eight")
  
  # create a df to save loop output in 
  sample_area_insecticide_day <- tibble()
  
  # extract individuals days, add day column and combine
  for (day in 1:length(days)) {
    
    day_pattern <- paste(".+-", day, "$", sep = "")
    
    day_alone <- sample_area_insecticide [grep(pattern = day_pattern, x = sample_area_insecticide$sample), ]
    
    day_alone$day <- days [day]
    
    sample_area_insecticide_day <- rbind(sample_area_insecticide_day, day_alone)
    
  }
  
  # add concentration to sample_area_insecticide_day
  
  # create concentration vector
  concentration_vector <- c(0.001, 0.01, 0.1, 1, 5)
  
  # create a df to save loop output in 
  sample_area_insecticide_day_concentration <- tibble()
  
  # extract individuals concentrations, add concentrations column and combine
  for (concentration in 1:length(concentration_vector)) {
    
    concentration_pattern <- paste(".+-", concentration_vector [concentration], "-.", sep = "")
    
    concentration_alone <- sample_area_insecticide_day [grep(pattern = concentration_pattern, x = sample_area_insecticide_day$sample), ]
    
    concentration_alone$concentration <- concentration_vector [concentration]
    
    sample_area_insecticide_day_concentration <- rbind(sample_area_insecticide_day_concentration, concentration_alone)
  }
  
  return(sample_area_insecticide_day_concentration)
  
}

model_df_anomalies_removed <- aucl_formatting_function(growthcurver_data = d_gc, aucl_or_r = 9)
```

Look at the variation by day. This variation was probably introduced by yeast cells not all being in mid-log phase growth, or variation in initial yeast cell number added to each well. 

```{r}
model_df_anomalies_removed <- model_df_anomalies_removed %>%
  reorder_levels(day, order = c("one", "two", "three", "four", "five", "six", "seven", "eight"))

boxplot(auc_l ~ day, data = model_df_anomalies_removed)
```

In my model I want to compare the interaction between no insecticide and concentration (controls) to the interaction between insecticides and concentration.

```{r}
# convert to factor
model_df_anomalies_removed$insecticide <- as.factor(model_df_anomalies_removed$insecticide)

# reorder insecticide factor so control comes first
model_df_anomalies_removed$insecticide <- relevel(model_df_anomalies_removed$insecticide, "control")

insect_conc_day_model <- lm(auc_l ~ insecticide + concentration + day + insecticide*concentration, data = model_df_anomalies_removed)

summary(insect_conc_day_model)
```

Test assumptions of linear regression.

```{r}
# Inspect the model diagnostic metrics
insect_conc_day_model_metrics <- augment(insect_conc_day_model)

# normality test
shapiro_result <- shapiro_test(insect_conc_day_model_metrics$.resid)

# homogoneity of variance
par(mfrow = c(2, 2))
plot(insect_conc_day_model)
```

Residuals don't have constant variance and shapiro test fails (not normally distributed). Look at the distribution of the dependent variable to visually identify potential transformation. Data is negatively skewed. A reflection and log transformation might make the dependent variable normally distributed. 

```{r}
density <- density(model_df_anomalies_removed$auc_l)

transformed_data <- model_df_anomalies_removed

# makes auc_l positively skewed
transformed_data$auc_l <- 1000 - transformed_data$auc_l

reflected_density <- density(transformed_data$auc_l)

transformed_data$auc_l <- log10(transformed_data$auc_l)

log_density <- density(transformed_data$auc_l)

layout(matrix(c(1,0,2,
                0,3,0), 2, 3, byrow = TRUE))

plot(density, main = "Density")

plot(reflected_density, main = "Reflected Density")

plot(log_density, main = "Log Reflected Density")

```

auc_l distribution looks closer to a normal distribution. Construct model again using this transformation and inspect residual plots etc.

```{r}
trans_insect_conc_day_model <- lm(auc_l ~ insecticide + concentration + day + insecticide*concentration, data = transformed_data)

summary(trans_insect_conc_day_model)

# Inspect the model diagnostic metrics
trans_insect_conc_day_model_metrics <- augment(trans_insect_conc_day_model)

# normality test
trans_shapiro_result <- shapiro_test(trans_insect_conc_day_model_metrics$.resid)

layout(matrix(c(1,1,2,3), 2, 2, byrow = TRUE))

# homogoneity of variance
plot(trans_insect_conc_day_model,c(1,2,5))
```

Interaction between thiacloprid and concentration is still significant. Investigate outliers.

Filter model metrics - return only samples with > absolute 2.95 standardised residual ([link](http://www.sthda.com/english/articles/39-regression-model-diagnostics/161-linear-regression-assumptions-and-diagnostics-in-r-essentials/#homogeneity-of-variance)) and mean cook's distance * 4 = 0.0136 ([link](http://r-statistics.co/Outlier-Treatment-With-R.html)) (high influence: this is comparable to 4/(n - p - 1) = 0.0115 ([link](http://www.sthda.com/english/articles/39-regression-model-diagnostics/161-linear-regression-assumptions-and-diagnostics-in-r-essentials/#homogeneity-of-variance))). Depending on sources extremely different interpretations of Cook's values and what constitutes influential. This ([link](https://online.stat.psu.edu/stat462/node/173/)) says >1 influential!

```{r}
# cook's distnace thresholds

# 4 / (nrow(trans_insect_conc_day_model_metrics) - 3- 1)

cook_cutoff <- mean(trans_insect_conc_day_model_metrics$.cooksd) * 4

stand_residual_cutoff <- 2.95

outliers_index <- which(trans_insect_conc_day_model_metrics$.cooksd > cook_cutoff & abs(trans_insect_conc_day_model_metrics$.std.resid) > stand_residual_cutoff)

outliers_metrics <- tibble()

colnames(outliers_metrics) <- colnames(trans_insect_conc_day_model_metrics)

for (outlier in 1:length(outliers_index)) {
  
  outlier_row <- trans_insect_conc_day_model_metrics [outliers_index [outlier], ]
  
  outliers_metrics <- rbind(outlier_row, outliers_metrics)
  
}
```

The cook’s distance for each observation i measures the change in Ŷ  (fitted Y) for all observations with and without the presence of observation i, so we know how much the observation i impacted the fitted values ([link](http://r-statistics.co/Outlier-Treatment-With-R.html)). How many of the observations above the cook cutoff are 5mM? 85%. The 5mM concentrations have a large influence over the fitted/predicted values. This is because Cook's distance depends on both residual (y value) and leverage (x value). Looking at the Cook's distance then is misleading because x was in experimental design.  

```{r}
above_cook_cutoff <- which(trans_insect_conc_day_model_metrics$.cooksd > cook_cutoff)

above_cook_cutoff_5_conc <- which(trans_insect_conc_day_model_metrics$.cooksd > cook_cutoff & trans_insect_conc_day_model_metrics$concentration == 5)

prop_high_cook <- length(above_cook_cutoff_5_conc) / length(above_cook_cutoff)
```

The observations above aren't anomalies. They are outliers and for this reason I can't exclude them from the data. After a log transformation the model residuals reject the null hypothesis of a shapiro-wilks test (the data distribution follows a normal distribution). 

I have to identify the distribution of my data. Fitdistrplus masks a part of tidyverse (I think). Once it's loaded the PCA plot fails. If I unload the package it doesn't solve the issue. I have to close R and reopen. This is why fitdistrplus isn't loaded at the beginning like the other packages. 

```{r}
library(fitdistrplus)

positive_skew <- 1000-(model_df_anomalies_removed$auc_l)

# mirror images of each other. I have reflected the negative skew by subtracting each score from a 
# constant that is larger than the largest score. Skewness is the same magnitude but in the opposite direction.

# plotdist(model_df_anomalies_removed$auc_l, histo = TRUE, demp = TRUE)

# descdist(model_df_anomalies_removed$auc_l, boot = 1000)

plotdist(positive_skew, histo = TRUE, demp = TRUE)

descdist(positive_skew, boot = 1000)

fit_wb <-  fitdist(positive_skew, "weibull")

fit_ln <-  fitdist(positive_skew, "lnorm")

fit_g <-  fitdist(positive_skew, "gamma")

par(mfrow = c(2, 2))

plot.legend <- c("weibull", "lognormal", "gamma")

denscomp(list(fit_wb, fit_ln, fit_g), legendtext = plot.legend)

qqcomp(list(fit_wb, fit_ln, fit_g), legendtext = plot.legend)

cdfcomp(list(fit_wb, fit_ln, fit_g), legendtext = plot.legend)
 
ppcomp(list(fit_wb, fit_ln, fit_g), legendtext = plot.legend)

summ_stats <- gofstat(list(fit_wb, fit_ln, fit_g),  fitnames = c("weibull", "lognormal", "gamma"))

# looks like lognnormal is the best fit with the lowest AIC score, and lowest for the other three statistics. What I don't 
# understand is how performing reflection and then log transforming the data didn't work because a lognormal distribution 
# looks like a pretty good approximation apart from one end of the distribution tail (QQ-plot). 
```

Contrary to the Shapiro Wilks Test, the AIC and other goodness of fit statistics suggest lognormal is the closest representation of the data distribution. This is supported by P-P plot, comparison of histogram with theoretical densities, comparison of empircal and theoretical CDF and partially by the Q-Q plot. 

I ran the analysis again without Thiacloprid-1-6, the only outlier with a standardised residual > 5. Now my data passes a Shapiro Wilks Test. All this means is "I cannot reject the hypothesis that the sample comes from a population which has a normal distribution". Due to this vaguery I ran my analysis with and without the observation. The interaction between Thiacloprid and Concentration was significant in comparison to the interaction between Control and Concentration for both. 

For a visualisation of mean AUC vs concentration for each insecticide (control part of insecticide)

```{r}
mean_plots_function <- function(d_gc) {
  
conditions_separately <- list()
conditions_stats <- tibble()

conditions <- c("control-", "acetamiprid-0.001", "acetamiprid-0.01", "acetamiprid-0.1", "acetamiprid-1","acetamiprid-5", "chlorpyrifos-0.001", "chlorpyrifos-0.01", "chlorpyrifos-0.1", "chlorpyrifos-1","chlorpyrifos-5", "clothianidin-0.001", "clothianidin-0.01", "clothianidin-0.1", "clothianidin-1","clothianidin-5", "cypermethrin-0.001", "cypermethrin-0.01", "cypermethrin-0.1", "cypermethrin-1", "cypermethrin-5", "flupyradifurone-0.001", "flupyradifurone-0.01", "flupyradifurone-0.1", "flupyradifurone-1","flupyradifurone-5", "imidacloprid-0.001", "imidacloprid-0.01", "imidacloprid-0.1", "imidacloprid-1","imidacloprid-5", "malathion-0.001", "malathion-0.01", "malathion-0.1", "malathion-1", "malathion-5", "sulfoxaflor-0.001", "sulfoxaflor-0.01", "sulfoxaflor-0.1", "sulfoxaflor-1", "sulfoxaflor-5", "tefluthrin-0.001", "tefluthrin-0.01", "tefluthrin-0.1", "tefluthrin-1", "tefluthrin-5", "thiacloprid-0.001", "thiacloprid-0.01", "thiacloprid-0.1", "thiacloprid-1", "thiacloprid-5")

for (name in 1:length(conditions)) {
  
  conditions_grouped <- d_gc %>% filter(str_detect(sample, conditions[name]))
  
  conditions_separately [name] <- conditions_grouped [ ,9]
  
  names(conditions_separately) [name] <- conditions[name]
  
  summ_stat <- stat.desc(conditions_separately[[name]])
  
  conditions_stats [name, 1] <- conditions[name]
  
  for (i in 1:length(summ_stat)) {
    
    conditions_stats [name, i+1] <- summ_stat [i]
    
  }
  
}

colnames(conditions_stats) <- c("condition", "nbr.val", "nbr.null", "nbr.na", "min", "max", "range", "sum", "median", "mean", "SE.mean", "CI.mean.0.95", "var", "std.dev", "coef.var")

# pull out condition AUC mean and AUC mean CI 95%
rel_conditions_stats <- conditions_stats [ , c(1, 10, 12)]

# separate each insecticide
insecticide_names <- c("acetamiprid", "chlorpyrifos", "clothianidin", "flupyradifurone", "imidacloprid", "malathion", "tefluthrin", "thiacloprid")

insecticide_list <- list()

for (name in 1:length(insecticide_names)) {

  insecticide_pattern <- paste0(insecticide_names[name], "-\\d*", sep = "")
  
  insecticide_x <- rel_conditions_stats %>% filter(str_detect(condition, insecticide_pattern))

  insecticide_list [[name]]  <- insecticide_x
  
  names(insecticide_list) [[name]] <- insecticide_names[name]
  
}

insecticide_list_1 <- list()

concentration <- c(0.001, 0.01, 0.1, 1, 5)

for (insecticide in 1:length(insecticide_list)) {
  
  insecticide_concs <- cbind(insecticide_list [[insecticide]], concentration)
  
  insecticide_list_1 [[insecticide]]  <- insecticide_concs
   
  names(insecticide_list_1) [[insecticide]] <- insecticide_names[insecticide]

}

# make control row
control_stats <- rel_conditions_stats %>% filter(str_detect(condition, "control"))
control_conc <- 0.0001
control_row <- cbind(control_stats, control_conc)
colnames(control_row) <- colnames(insecticide_list_1[[1]])

# bind it to the other insecticide dataframes
insecticide_list_2 <- list()

for (insecticide in 1:length(insecticide_list_1)) {
  
  insecticide_control <- rbind(insecticide_list_1 [[insecticide]], control_row)
  
  insecticide_list_2 [[insecticide]]  <- insecticide_control
   
  names(insecticide_list_2) [[insecticide]] <- insecticide_names[insecticide]

}

require(scales)

plot_list <- list()

for (insecticide in 1:length(insecticide_list_2)) {
  
  title <- paste0(names(insecticide_list_2[insecticide]), sep = "" )
  
  df <- insecticide_list_2[[insecticide]]

  df$facet <- ifelse(df$concentration == min(df$concentration), 1, 2)
  
  drc <- ggplot(df, aes(x=concentration,y=mean)) +
    geom_point(data = subset(df, facet == 1)) +
    geom_point(data = subset(df, facet == 2)) +
    scale_x_log10(breaks = c(0.0001, 10^(-3:10)), 
                labels = c(0, math_format()(-3:10))) +
    geom_errorbar(aes(ymin=mean-CI.mean.0.95, ymax=mean+CI.mean.0.95), width=.1) + 
    ylim(0, 900) +
    ggtitle(title) +
    labs(x="", y="",size=1) +
    facet_grid(~facet, scales = 'free', space = 'free') +
    theme(panel.background = element_rect(fill = "white"),
    axis.line = element_line(), strip.text.x = element_blank()
    )
  
  plot_list [[insecticide]] <- drc

}

return(plot_list)

}

mean_plots <- mean_plots_function(d_gc)

add_global_label <- function(pwobj, Xlab = NULL, Ylab = NULL, Xgap = 0.03, Ygap = 0.03, ...) {
    ylabgrob <- patchwork::plot_spacer()
    if (!is.null(Ylab)) {
        ylabgrob <- ggplot() +
            geom_text(aes(x = .5, y = .5), label = Ylab, angle = 90, ...) +
            theme_void()
    }
    if (!is.null(Xlab)) {
        xlabgrob <- ggplot() +
            geom_text(aes(x = .5, y = .5), label = Xlab, ...) +
            theme_void()
    }
    if (!is.null(Ylab) & is.null(Xlab)) {
        return((ylabgrob + patchworkGrob(pwobj)) + 
            patchwork::plot_layout(widths = 100 * c(Ygap, 1 - Ygap)))
    }
    if (is.null(Ylab) & !is.null(Xlab)) {
        return((ylabgrob + pwobj) + 
            (xlabgrob) +
            patchwork::plot_layout(heights = 100 * c(1 - Xgap, Xgap),
                                   widths = c(0, 100),
                                   design = "
                                   AB
                                   CC
                                   "
            ))
    }
    if (!is.null(Ylab) & !is.null(Xlab)) {
        return((ylabgrob + pwobj) + 
            (xlabgrob) +
            patchwork::plot_layout(heights = 100 * c(1 - Xgap, Xgap),
                                   widths = 100 * c(Ygap, 1 - Ygap),
                                   design = "
                                   AB
                                   CC
                                   "
            ))
    }
    return(pwobj)
}

add_global_label((wrap_plots(mean_plots)),
                 Ylab = "AUC", Xlab = "Concentration")
```

For a visualisation of mean AUC vs concentration for each insecticide (control (no insecticide) separate.

```{r}
control_sep_mean_plots_function <- function(d_gc) {
  
conditions_separately <- list()
conditions_stats <- tibble()

conditions <- c("control-0.001", "control-0.01","control-0.1","control-1","control-5", "acetamiprid-0.001", "acetamiprid-0.01", "acetamiprid-0.1", "acetamiprid-1","acetamiprid-5", "chlorpyrifos-0.001", "chlorpyrifos-0.01", "chlorpyrifos-0.1", "chlorpyrifos-1","chlorpyrifos-5", "clothianidin-0.001", "clothianidin-0.01", "clothianidin-0.1", "clothianidin-1","clothianidin-5", "cypermethrin-0.001", "cypermethrin-0.01", "cypermethrin-0.1", "cypermethrin-1", "cypermethrin-5", "flupyradifurone-0.001", "flupyradifurone-0.01", "flupyradifurone-0.1", "flupyradifurone-1","flupyradifurone-5", "imidacloprid-0.001", "imidacloprid-0.01", "imidacloprid-0.1", "imidacloprid-1","imidacloprid-5", "malathion-0.001", "malathion-0.01", "malathion-0.1", "malathion-1", "malathion-5", "sulfoxaflor-0.001", "sulfoxaflor-0.01", "sulfoxaflor-0.1", "sulfoxaflor-1", "sulfoxaflor-5", "tefluthrin-0.001", "tefluthrin-0.01", "tefluthrin-0.1", "tefluthrin-1", "tefluthrin-5", "thiacloprid-0.001", "thiacloprid-0.01", "thiacloprid-0.1", "thiacloprid-1", "thiacloprid-5")

for (name in 1:length(conditions)) {
  
  conditions_grouped <- d_gc %>% filter(str_detect(sample, conditions[name]))
  
  conditions_separately [name] <- conditions_grouped [ ,9]
  
  names(conditions_separately) [name] <- conditions[name]
  
  summ_stat <- stat.desc(conditions_separately[[name]])
  
  conditions_stats [name, 1] <- conditions[name]
  
  for (i in 1:length(summ_stat)) {
    
    conditions_stats [name, i+1] <- summ_stat [i]
    
  }
  
}

colnames(conditions_stats) <- c("condition", "nbr.val", "nbr.null", "nbr.na", "min", "max", "range", "sum", "median", "mean", "SE.mean", "CI.mean.0.95", "var", "std.dev", "coef.var")

# pull out condition AUC mean and AUC mean CI 95%
rel_conditions_stats <- conditions_stats [ , c(1, 10, 12)]

# separate each insecticide
insecticide_names <- c("control", "acetamiprid", "chlorpyrifos", "clothianidin", "flupyradifurone", "imidacloprid", "malathion", "tefluthrin", "thiacloprid")

insecticide_list <- list()

for (name in 1:length(insecticide_names)) {

  insecticide_pattern <- paste0(insecticide_names[name], "-\\d*", sep = "")
  
  insecticide_x <- rel_conditions_stats %>% filter(str_detect(condition, insecticide_pattern))

  insecticide_list [[name]]  <- insecticide_x
  
  names(insecticide_list) [[name]] <- insecticide_names[name]
  
}

insecticide_list_1 <- list()

concentration <- c(0.001, 0.01, 0.1, 1, 5)

for (insecticide in 1:length(insecticide_list)) {
  
  insecticide_concs <- cbind(insecticide_list [[insecticide]], concentration)
  
  insecticide_list_1 [[insecticide]]  <- insecticide_concs
   
  names(insecticide_list_1) [[insecticide]] <- insecticide_names[insecticide]

}

require(scales)

plot_list <- list()

for (insecticide in 1:length(insecticide_list_1)) {
  
  title <- paste0(names(insecticide_list_1[insecticide]), sep = "" )
  
  df <- insecticide_list_1[[insecticide]]
  
  
  drc <- ggplot(df, aes(x=concentration,y=mean)) +
    geom_point() +
    scale_x_log10(breaks = c(0.0001, 10^(-3:10)), 
                labels = c(0, math_format()(-3:10))) +
    geom_errorbar(aes(ymin=mean-CI.mean.0.95, ymax=mean+CI.mean.0.95), width=.1) + 
    ylim(0, 900) +
    ggtitle(title) +
    labs(x="", y="",size=1) +
    theme(panel.background = element_rect(fill = "white"),
    axis.line = element_line(), strip.text.x = element_blank()
    )
  
  plot_list [[insecticide]] <- drc

}

return(plot_list)

}

control_sep_mean_plots <- control_sep_mean_plots_function(d_gc)

add_global_label((wrap_plots(control_sep_mean_plots)),
                 Ylab = "AUC", Xlab = "Concentration")
```

Plot individual replicates by day for each insecticide with a line connecting them.

```{r}
formatted_growthcurver_df <- aucl_formatting_function(growthcurver_data = growthcurver_data, aucl_or_r = 9)
```

Split by insecticide

```{r}
by_insecticide_df_function <- function(formatted_growthcurver_df) {
  
  # split assigned_controls_df into 8 lists by insecticide. Also split each insecticide by day. 

  # define 8 insecticides
  eight_insecticides <- c("control", "acetamiprid", "chlorpyrifos", "clothianidin", "flupyradifurone", "imidacloprid", "malathion", "tefluthrin", "thiacloprid")
  
  # create list to save loop output
  insecticide_list <- list()
  
  # split insecticides into their own dfs within a list
  for (insecticide in 1:length(eight_insecticides)) {
    
    insecticide_alone <- formatted_growthcurver_df [grep(pattern = eight_insecticides [insecticide], x = formatted_growthcurver_df$insecticide), ]
    
    insecticide_list [[insecticide]] <- insecticide_alone
    
    names(insecticide_list) [[insecticide]] <- eight_insecticides[insecticide]
    
  }
  
  return(insecticide_list)
  
}

by_insecticide_dfs <- by_insecticide_df_function(formatted_growthcurver_df)

```

Plot controls separate from insecticide. Get an idea of variation between insecticides. 

```{r}
plot_list <- list()

for (insecticide in 1:length(by_insecticide_dfs)) {
  
  title <- paste0(names(by_insecticide_dfs[insecticide]), sep = "" )
  
  df <- by_insecticide_dfs[[insecticide]]

  drc <- ggplot(df, aes(x=concentration,y=auc_l, color=day)) +
    geom_point() +
    geom_line() +
    scale_x_log10(breaks = trans_breaks("log10", function(x) 10^x),
                  labels = trans_format("log10", math_format(10^.x))) +    ylim(0, 1500) +
    ggtitle(title) +
    labs(x="", y="") +
    theme(panel.background = element_rect(fill = "white"), axis.line = element_line(), axis.title = element_text(size = 10),
          plot.title = element_text(size = 12))
  
  plot_list [[insecticide]] <- drc

}
add_global_label((wrap_plots(plot_list)),
                 Ylab = "AUC", Xlab = "Concentration") + plot_layout(guides = "collect")
```

Does looking at growth rate (r) change any of the results? 

```{r}
model_df_anomalies_removed_r <- aucl_formatting_function(growthcurver_data = d_gc, aucl_or_r = 4)

transformed_data_r <- model_df_anomalies_removed_r

# makes r positively skewed
transformed_data_r$r <- 1000 - transformed_data_r$r

transformed_data_r$r <- log10(transformed_data_r$r)

trans_insect_conc_day_model_r <- lm(r ~ insecticide + concentration + day + insecticide*concentration, data = transformed_data_r)

summary(trans_insect_conc_day_model_r)
```

Interaction between thiacloprid and concentration is again significant. Less of the variation described by the model though.

Try and use a mixed model with day as a random effect. Difference between day explains 41% of the variance remaining after the variance explain by fixed effects. 

Only fitted random-intercept model. A random-intercept model allows the intercept to vary for each level of the random effects, but keeps the slope constant among them. The intercept in this case is the initial growth on a certain day. So growth on some days may be larger or smaller to begin with. This assumes that the relationship between growth and insecticide concentration is the same on all days. 

I could do a random-slope and random intercept model. This would allow both to intercept and slope to vary. So both baseline growth (intercept) and the relationship between growth and insecticide concentration (slope) can vary by day. However, I think it is unlikely for the relationship between growth and insecticide concentration to vary between days. Also, can't get it to work.

Testing significance becomes complex for mixed models. This guide ([mixed models](http://bbolker.github.io/mixedmodels-misc/glmmFAQ.html#inference-and-confidence-intervals)) runs through some options. Models need to be nested (mine are [link](https://www.stat.ncsu.edu/people/bloomfield/courses/st430/slides/MandS-ch04-sec13-14.pdf)). Reference for LRT of fixed effects ([link](https://www.ssc.wisc.edu/sscc/pubs/MM/MM_TestEffects.html))

```{r}
library(lme4)

mixed.lmer <- lmer(auc_l ~ insecticide*concentration + (1|day), data = transformed_data)

# how would i get this to work?
# mixed.lmer_1 <- lmer(auc_l ~ insecticide*concentration + (1 + insecticide*concentration|day), data = transformed_data)

summary(mixed.lmer)

plot(mixed.lmer)

# below will be same as above for linear model
qqnorm(resid(mixed.lmer))

qqline(resid(mixed.lmer))

# model and term significance.
full.lmer <- lmer(auc_l ~ insecticide*concentration + (1|day), data = transformed_data, REML = FALSE)

reduced.lmer <- lmer(auc_l ~ 1 + (1|day), data = transformed_data, REML = FALSE)

anova(reduced.lmer, full.lmer) 

drop1(full.lmer,test="Chisq")


```

Make model outputs presentable using sjPlot. 