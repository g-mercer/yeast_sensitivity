---
title: "insecticides_growthcurver_1"
author: "Guy Mercer"
date: "02/10/2020"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE, message = FALSE, warning = FALSE)
```

Machine Settings:

* Number of Cycles - 192

* Cycle Length - 300s

* Wavelength - 600nm

* Temperature - 30°C

* Shake - Before Each Cycle (272s)

* Shake Mode - Double Orbital

* Shake Frequency - 200rpm

* Total Well Volume - 200µl

I combined all the replicates using zsh to output a formatted, compiled csv file called formatted_compiled. I then edited the names of controls and blanks.

```{zsh raw-file-formatting}
#!/usr/bin/env zsh

# setwd
cd /Users/guy/Documents/phd/DEG_yeast_insecticide_expt/senstivity_test/insecticides_sens

./WHATIDID.sh 
```

```{r}
library(tidyverse)
library(knitr)
library(growthcurver)
library(pastecs)
library(rstatix)
library(lmerTest)
library(ibd)
library(ggpubr)
library(broom)
library(patchwork)
``` 

```{r}
# set wd
setwd("~/Documents/phd/DEG_yeast_insecticide_expt/senstivity_test/insecticides_sens/")

# read csv
insect_sens <- read.csv(file = "./results/form_comp_corr_blank_cont.csv", header = FALSE, stringsAsFactors = FALSE)

# formatting function
sens_data_form <- function(sens_data) {
  # transpose
  sens_data_trans <- t(sens_data)
  # save first row as colnames
  colnames(sens_data_trans) <- sens_data_trans [1, ]
  # delete first row, which is now duplicate of colnames
  sens_data_colnames <- sens_data_trans [-1, ]
  # remove any empty rows. Sometimes created when importing csv file 
  sens_data_no_blanks <- sens_data_colnames[rowSums(is.na(sens_data_colnames)) != ncol(sens_data_colnames),]
  # convert matrix into dataframe
  sens_data_df <- as.data.frame(sens_data_no_blanks)
  # convert everything to numeric
  sens_data_df[] <- lapply(sens_data_df, function(x) {
    if(is.factor(x)) as.numeric(as.character(x)) else x
  })
  # convert to data frame
  sens_data_corr <- as.data.frame(sens_data_df)
  
  return(sens_data_corr)
}

sens_data_corr <- sens_data_form(insect_sens)

# set any negative values to 0
sens_data_corr[sens_data_corr<0] <- 0
```

To input the data into Growthcurver I had to alter the formatting. When using Growthcurver, columns have to be looped through individually for a more detailed output. Growth curve data is fitted to the standard form of the logistic equation (sigmoidal).

```{r, include = FALSE}
growthcurver_function <- function(sens_data_corr) {
  
# Let's create an output data frame to store the results in. 
# We'll create it so that it is the right size (it's faster this way!), 
# but leave it empty.
num_analyses <- length(names(sens_data_corr)) - 1
d_gc <- data.frame(sample = character(num_analyses),
                   k = numeric(num_analyses),
                   n0  = numeric(num_analyses),
                   r = numeric(num_analyses),
                   r_se = numeric(num_analyses),
                   r_p = numeric(num_analyses),
                   t_mid = numeric(num_analyses),
                   t_gen = numeric(num_analyses),
                   auc_l = numeric(num_analyses),
                   auc_e = numeric(num_analyses),
                   sigma = numeric(num_analyses),
                   stringsAsFactors = FALSE)

# Now, loop through all of the columns in the data frame. For each column,
# run Growthcurver, save the most useful metrics in the output data frame,
# and make a plot of all the growth curve data and their best fits.
par(mfcol = c(4,4))
par(mar = c(1,1,1,1))
y_lim_max <- max(sens_data_corr[,setdiff(names(sens_data_corr), "time")]) - min(sens_data_corr[,setdiff(names(sens_data_corr), "time")])

n <- 1    # keeps track of the current row in the output data frame
for (col_name in names(sens_data_corr)) {
  
  # Don't process the column called "time". 
  # It contains time and not absorbance data.
  if (col_name != "time") {
    
    # Create a temporary data frame that contains just the time and current col
    sens_data_corr_loop <- sens_data_corr[, c("time", col_name)]
    
    # Now, call Growthcurver to calculate the metrics using SummarizeGrowth
    gc_fit <- SummarizeGrowth(data_t = sens_data_corr_loop[, "time"], 
                              data_n = sens_data_corr_loop[, col_name],
                              bg_correct = "none")
    
    # Now, add the metrics from this column to the next row (n) in the 
    # output data frame, and increment the row counter (n)
    d_gc$sample[n] <- col_name
    d_gc[n, 2:11] <- c(gc_fit$vals$k,
                       gc_fit$vals$n0,
                       gc_fit$vals$r,
                       gc_fit$vals$r_se,
                       gc_fit$vals$r_p,
                       gc_fit$vals$t_mid,
                       gc_fit$vals$t_gen,
                       gc_fit$vals$auc_l,
                       gc_fit$vals$auc_e,
                       gc_fit$vals$sigma)
    n <- n + 1
    
    # Finally, plot the raw data and the fitted curve
    n_obs <- length(gc_fit$data$t)
    plot(gc_fit$data$t, gc_fit$data$N, 
         pch = 20, 
         xlim = c(0, 960), 
         ylim = c(0, y_lim_max),
         cex = 0.6, xaxt = "n", yaxt = "n")
    text(x = 960 / 2, y = y_lim_max, labels = col_name, pos = 1)
    lines(gc_fit$data$t, predict(gc_fit$model),col = "red")
  }
}

# Uncomment the next line to save the plots from your 96-well plate to a file
# dev.off()

return(d_gc)

}

d_gc <- growthcurver_function(sens_data_corr = sens_data_corr)
```

There is something odd about sens_data_corr. When passing it to d_gc the replicate growth curves are no longer plotted. If, however, I set replicates_of_interest <- colnames(sens_data_corr) below. Then the individual plots are output. Even so on the surface replicates_of_interest_df is the same as sens_data_corr???? No there isn't. The plot output is set to only take 16. 

```{r}
# replicates_of_interest <- colnames(sens_data_corr)
  
replicates_of_interest <- c("time", "chlorpyrifos-0.1-7", "tefluthrin-0.1-7", "thiacloprid-5-4", "thiacloprid-5-5", "control-5-7", "thiacloprid-1-3", "control-1-8", "imidacloprid-0.01-8", "flupyradifurone-0.01-8", "thiacloprid-1-6")

replicates_of_interest_df <- tibble(matrix(nrow=nrow(sens_data_corr)))

for (sample in 1:length(replicates_of_interest)) {
  
  replicate_col <- sens_data_corr [ , grep(pattern = replicates_of_interest [sample], x = names(sens_data_corr))]
  
  replicates_of_interest_df [ , sample] <- replicate_col
  
}

colnames(replicates_of_interest_df) <- replicates_of_interest 

replicates_of_interest_curves <- growthcurver_function(sens_data_corr = replicates_of_interest_df)

```

Above are replicates removed for technical reasons such as solubility and pipetting errors. Cypermethrin was removed completely because 5mM precipitated out. 

Sigma values represent the residual sum of squares from the fit of the logistic curve to the data, so larger values mean poorer fit to logistic model. Cypermethrin's solubility issues artificially increased its starting OD readings, leading to a poor model fit. 

```{r}
d_gc <- as_tibble(d_gc)

# Plot a histogram of the sigma values in order to check for outliers
hist(d_gc$sigma, main = "Histogram of sigma values", xlab = "sigma")

# Show the top 50 samples with the largest sigma value 
# (with the worst model fit to the growth curve data)
high_sigma <- d_gc %>% top_n(50, sigma) %>% arrange(desc(sigma))
```

One additional method for identifying outlier parameters is to conduct a principal components analysis on the samples, which projects high dimensional data on lower dimensional space. Plotting the samples on the first two principal components (PC1 and PC2) can identify natural clusters within the growth curve data as well as outliers.

```{r}
pca_gc_out <- as_tibble(d_gc) 

# Prepare the gc_out data for the PCA
rownames(pca_gc_out) <- pca_gc_out$sample

# Do the PCA
pca.res <- prcomp(pca_gc_out %>% select(k:sigma), center=TRUE, scale=TRUE)

# pdf(file="pca.pdf") if i want to save the plot
# Plot the results
as_tibble(list(PC1=pca.res$x[,1],
                   PC2=pca.res$x[,2],
                   samples = rownames(pca_gc_out))) %>% 
  ggplot(aes(x=PC1,y=PC2, label=samples)) + 
geom_text(size = 1)
# dev.off()
```

```{r}
# save a complete version of the data with all the outliers
growthcurver_data <- d_gc
```

Need to remove outliers through a combination of PCA, sigma values and visual inspection of plots. Samples are removed if they fit the following three criteria: not bound by PCA y = -4 and x = 5, sigma > 0.05 and obvious error from visual inspection of plots. There were also some possible pipetting anomalies, described separately below. 

```{r}
anomalies <- c("chlorpyrifos-0.1-7", "tefluthrin-0.1-7", "thiacloprid-5-4", "thiacloprid-5-5", "thiacloprid-1-3", "control-5-7")

for (sample in 1:length(anomalies)) {
  
  d_gc <-  d_gc [-grep(pattern = anomalies [sample], x = d_gc$sample), ]
  
}

pipetting_anomalies <- c("control-1-8", "imidacloprid-0.01-8", "flupyradifurone-0.01-8")

for (sample in 1:length(pipetting_anomalies)) {
  
  d_gc <-  d_gc [-grep(pattern = pipetting_anomalies [sample], x = d_gc$sample), ]
  
}
# I see no reason to remove this. If I do though it is the difference between failing and passing a shapiro wilks test once data is transformed. Thiacloprid significant both with and without
d_gc <-  d_gc [-grep(pattern = "thiacloprid-1-6", x = d_gc$sample), ]

```

Best option is to have three independent variables: concentration (factor), insecticide (factor) and day (factor) and one dependent variable: AUC (continuous dependent). AUC = concentration + pesticide + day + (pesticide x concentration) (interaction).  pesticide x concentration interaction is the interesting term. Use a linear mixed model with day as a random effect. To do this the data has to be reformatted so there are columns with concentration, day and insecticide. At this point sulfoxaflor and cypermethrin were removed due to evaporation and solubility issues respectively. 

```{r}
aucl_formatting_function <- function(growthcurver_data, aucl_or_r) {
  
  # subset from growthcurver_data the two required columns
  sample_area <- growthcurver_data [, c(1, aucl_or_r)]
  
  # remove sulfoxaflor and cypermethrin
  sample_area <- sample_area [-grep(pattern = "(cypermethrin|sulfoxaflor)", x = sample_area$sample), ]
  
  # add insecticide column to sample_area
  
  # create vector with remaining insecticides
  eight_insecticides <- c("acetamiprid", "chlorpyrifos", "clothianidin", "flupyradifurone", "imidacloprid", "malathion", "tefluthrin", "thiacloprid", "control")
  
  # create a df to save loop output in 
  sample_area_insecticide <- tibble()
  
  # extract individual insecticides, add insecticide column and recombine
  for (insecticide in 1:length(eight_insecticides)) {
    
    insecticide_alone <-  sample_area [grep(pattern = eight_insecticides [insecticide], x = sample_area$sample), ]
    
    insecticide_alone$insecticide <- eight_insecticides [insecticide]
    
    sample_area_insecticide <- rbind(sample_area_insecticide, insecticide_alone)
    
  }
  
  # add day to sample_area_insecticide
  
  # create day
  days <- c("one", "two", "three", "four", "five", "six", "seven", "eight")
  
  # create a df to save loop output in 
  sample_area_insecticide_day <- tibble()
  
  # extract individuals days, add day column and combine
  for (day in 1:length(days)) {
    
    day_pattern <- paste(".+-", day, "$", sep = "")
    
    day_alone <- sample_area_insecticide [grep(pattern = day_pattern, x = sample_area_insecticide$sample), ]
    
    day_alone$day <- days [day]
    
    sample_area_insecticide_day <- rbind(sample_area_insecticide_day, day_alone)
    
  }
  
  # add concentration to sample_area_insecticide_day
  
  # create concentration vector
  concentration_vector <- c("0.001", "0.01", "0.1", "1", "5")
  
  # create a df to save loop output in 
  sample_area_insecticide_day_concentration <- tibble()
  
  # extract individuals concentrations, add concentrations column and combine
  for (concentration in 1:length(concentration_vector)) {
    
    concentration_pattern <- paste(".+-", concentration_vector [concentration], "-.", sep = "")
    
    concentration_alone <- sample_area_insecticide_day [grep(pattern = concentration_pattern,
                                                             x = sample_area_insecticide_day$sample), ]
    
    concentration_alone$concentration <- concentration_vector [concentration]
    
    sample_area_insecticide_day_concentration <- rbind(sample_area_insecticide_day_concentration, concentration_alone)
  }
  
  return(sample_area_insecticide_day_concentration)
  
}

model_df_anomalies_removed <- aucl_formatting_function(growthcurver_data = d_gc, aucl_or_r = 9)
```

Look at the variation by day. This variation was probably introduced by yeast cells not all being in mid-log phase growth, or variation in initial yeast cell number added to each well. 

```{r}
model_df_anomalies_removed <- model_df_anomalies_removed %>%
  reorder_levels(day, order = c("one", "two", "three", "four", "five", "six", "seven", "eight"))

boxplot(auc_l ~ day, data = model_df_anomalies_removed)
```

In my model I want to see whether there is an interaction between concentration and insecticide. I need to randomly distribute the controls to the insecticides using IBD. 

I need to evenly distribute 40 controls amongst 8 insecticides so that the day effect will be minimised. This requires balanced incomplete block design ([link](https://stat.ethz.ch/~meier/teaching/anova/incomplete-block-designs.html)). In my case I have 8 days (treatment, g), 8 insecticides (blocks, b), 5 samples/units per insecticide (k) and 5 replicates per day (r).

Remember: N = b * k = g * r 

Therefore, 40 samples to be shared among 8 insecticides, making 5 samples per insecticide. Evenly distributed according to day (5 replicates per day).

In this case a BIBD doesn't exist because for 

r.(k-1) = λ.(g-1)

λ isn't a whole number. 

There is, however, an incomplete block design.
 
```{r}
# the first output shows the block design and the second is a concurrence matrix and shows 
# how many times any pair of treatments appears together in the same block. 
bibd <- ibd(v = 8, b = 8, k = 5)

bibd$design

# shows how many days each block shares
# kable(bibd$conc.mat)
```

Following the block design above I need to allocate the controls to the insecticides.

```{r}
ibd_control_assignment_function <- function(model_df_anomalies_removed) {

  only_controls <- model_df_anomalies_removed[grep("control", model_df_anomalies_removed$insecticide), ]

  insecticide_names <- c("acetamiprid", "chlorpyrifos", "clothianidin", "flupyradifurone", "imidacloprid", "malathion", "tefluthrin", "thiacloprid")
  
  insecticide_names <- sample(insecticide_names)
  
  # make day_numerical_column
  day_numerical <- rep(1:8, times = 1)
  
  day_factor <- only_controls$day
  
  day_factor_unique <- unique(day_factor)
  
  for (i in 1:length(day_factor_unique)) {
    
    day_factor <- gsub(pattern = day_factor_unique [i], replacement = i, x = day_factor )
    
  }
  
  only_controls$day_numerical <- day_factor
  
  model_df <- model_df_anomalies_removed[-grep("control", model_df_anomalies_removed$insecticide), ]

  for (insecticide in 1:length(insecticide_names)) {
  
    ibd_row <- bibd$design [insecticide, ]

    four_controls <- tibble()

    for (day in 1:length(ibd_row)) {
  
      ibd_day <- only_controls[grep(ibd_row [day], only_controls$day_numerical), ]
  
      random_control <- ibd_day[sample(nrow(ibd_day), 1), ]
  
      only_controls <- setdiff(only_controls, random_control)
  
      four_controls <- rbind(four_controls, random_control)
  
    }

    four_controls$insecticide <- gsub("control", insecticide_names [insecticide], four_controls$insecticide)

    model_df <- rbind(model_df, four_controls [ ,1:5])

  }
  
  return(model_df)

}

model_df_assigned_controls <- ibd_control_assignment_function(model_df_anomalies_removed)

# give controls conc of 0
only_controls <- model_df_assigned_controls [grep(pattern = "control", x = model_df_assigned_controls$sample), ]

model_df_assigned_controls <- model_df_assigned_controls [-grep(pattern = "control", x = model_df_assigned_controls$sample), ]

only_controls$concentration <- "0"

model_df_assigned_controls <- rbind(model_df_assigned_controls, only_controls)
```

Remember that when you run the chunk above you randomly assign the controls to the insecticides again according to the IBD. See if doing this varies the results. Would show the control assignment does have an effect. Could do because I'm using an incomplete block design.

Controls have been distributed to each insecticide level within insecticide factor and 0 level in concentration factor. 

```{r}
concs_own_level <- model_df_anomalies_removed

model_df_anomalies_removed <- model_df_assigned_controls

# convert insecticide to factor
model_df_anomalies_removed$insecticide <- as.factor(model_df_anomalies_removed$insecticide)

# convert concentration to factor
model_df_anomalies_removed$concentration <- as.factor(model_df_anomalies_removed$concentration)

# reorder concentration factor so "0" (control) comes first
model_df_anomalies_removed$concentration <- relevel(model_df_anomalies_removed$concentration, "0")

# reorder insecticide factor so tefluthrin comes first. Chosen because there is no effect at any concentration. Change to acetamiprid. 
model_df_anomalies_removed$insecticide <- relevel(model_df_anomalies_removed$insecticide, "tefluthrin")

```

An important question is what does the intercept of my model represent? For a simple linear regression of a categorical variable with two levels the intercept would be one of the levels, with the other level contrasted to this level. Eg. male and female levels in sex categorical variable in car package salaries example data set ([link](http://www.sthda.com/english/articles/40-regression-analysis/163-regression-with-categorical-variables-dummy-coding-essentials-in-r/#example-of-data-set)). For more complex models like mine this isn't the case. For this model the intercept is very similar to acet 0. The reason it isn't exactly the same is because the interaction terms including day are omitted from the model 

```{r}
acet <- model_df_anomalies_removed [grep(pattern = "acetamiprid", x = model_df_anomalies_removed$insecticide), ]
acet_0 <- acet [grep(pattern = "^0$", x = acet$concentration), ]
mean(acet_0$auc_l)
```

The above figure is close to intercept term of model. How to interpret the model output? My model has two fixed explanatory factor variables. To calculate the estimated mean of chlorpyrifos_1 from the model summary= 675.999 (Intercept) + 30.403 (chlorpyrifos) + 36.593 (concentration1) - 96.057 (insecticidechlorpyrifos:concentration1) = 646.9381. This is the same as if we calculated the actual mean! (Update to change values automatically)

Another example is Thiacloprid 5. model summary= 675.999 (Intercept) + 4.763 (thiacloprid) + 36.593 (concentration5) - 96.057 (insecticidethiacloprid:concentration5) = 407.544. This is (basically) the same as if we calculated the actual mean! 

The thiacloprid value is only applicable alone to concentration 0 without the interaction term. Likewise, the concentration5 value is only relevant alone to insecticide acetamiprid. Eg, to find the estimated mean of acetamiprid 5 = Intercept + concentration 5. To find the estimated mean of thiacloprid 0 = Intercept + thiacloprid. Therefore, concentration 5 shows the difference between the estimated means of acetamiprid 0 and acetamiprid 5 and thiacloprid row shows the difference between estimated means of acetamiprid 0 and thiacloprid 0. The difference between the estimated means of acetamiprid 0 and thiacloprid 5 = thiacloprid + concentration 5 + concentration5:insecticidethiacloprid. This shows the effects of concentration depends on insecticide, or the effects of insecticide depend on concentration. 

My analysis shows there is an interaction between insecticide thiacloprid and concentration 5. It doesn't test the difference between acet-0 and thia-5 per se.

When the insecticide is thiacloprid the AUC decreases substantially with concentration such that concentration 5 observations are substantially lower than those from concentration 0.

For a refresher on interpreting models with two factors go to Knell's Linear models 4: Multi-factor ANOVA - Interpretation section of his tutorials. 

My problem with this approach is the interaction term values are relative to the reference levels. For example,

estimated mean of thia-5 = intercept + conc_5 + thia + conc_5:thia

conc_5 = the effect of conc_5 on growth for acet (relative to acet-0) if acet is the reference insecticide level. 

thia = effect of thia on growth for conc_0 (relative to acet-0). 

Of the two contrasts above thia doesn't matter because there shouldn't be any significant difference between thia-0 and acet-0. However, if there is an effect for conc_5 on growth for acet the interaction term for conc_5:thia has to take this into account (because the interaction term value is modifying the separate effects of conc_5 and thia on growth to account for their effect when together) . Therefore, the value of the interaction terms are dependent on the reference levels set. conc_5:thia will alter if acet is the insecticide reference level in comparison to if tefluthrin is (because the effect of conc_5 on acet is different to the effect of conc_5 on teflu). This is especially pronounced for this example (teflu vs acet reference level) because acetamiprid seems to have a proliferative effect at all concentrations. 

In summary, the choice of insecticide reference level alters the values and significance of the interaction terms and I don't like this. 

```{r}
chlor <- model_df_anomalies_removed [grep(pattern = "imidacloprid", x = model_df_anomalies_removed$insecticide), ]
chlor_1 <- chlor [grep(pattern = "^0.1$", x = chlor$concentration), ]
mean(chlor_1$auc_l)

thia <- model_df_anomalies_removed [grep(pattern = "thiacloprid", x = model_df_anomalies_removed$insecticide), ]
thia_5 <- thia [grep(pattern = "^5$", x = thia$concentration), ]
mean(thia_5$auc_l)
```

```{r}
mixed.lmer <- lmer(auc_l ~ concentration * insecticide + (1|day), data = model_df_anomalies_removed)

summary(mixed.lmer)

# make a model without the interaction term to check if an insecticide is having an effect at all concentrations
mixed.lmer_no_interaction <- lmer(auc_l ~ concentration + insecticide + (1|day), data = model_df_anomalies_removed)

summary(mixed.lmer_no_interaction)

plot(mixed.lmer)

qqnorm(resid(mixed.lmer))

qqline(resid(mixed.lmer))

# model and term significance.
full.lmer <- lmer(auc_l ~ concentration * insecticide + (1|day), data = model_df_anomalies_removed, REML = FALSE)

reduced.lmer <- lmer(auc_l ~ concentration + insecticide + (1|day), data = model_df_anomalies_removed, REML = FALSE)

anova(reduced.lmer, full.lmer) 

drop1(full.lmer,test="Chisq")
```
If thiacloprid is made reference level in insecticide factor it can clearly be shown that concentration 5 has a significant effect for the thiacloprid level of the insecticide factor.

Fit the model without the interaction term. Now the rows correspond to the effect of that level, relative to the reference level for the factor, which is the same across all the levels of the other factor. For example, acetamiprid has a significant positive effect on growth relative to tefluthrin, and this applies to all concentrations equally. Or, concentration 5 has a significant negative effect on growth relative to concentration 0, irrespective of the insecticide.  

Remember the myths of linear regression. The dependent variable doesn't need to be normally distributed. The model residuals, however, do. 

There are four basic assumptions of linear regression. These are:

the mean of the data is a linear function of the explanatory variable(s)*;
the residuals are normally distributed with mean of zero;
the variance of the residuals is the same for all values of the explanatory variables; and
the residuals should be independent of each other.

([link](https://mickteaching.wordpress.com/2016/04/19/data-need-to-be-normally-distributed-and-other-myths-of-linear-regression/#:~:text=Neither%20is%20required.,of%20the%20residuals%20is%20zero.))

REMEMBER THIS!

Residuals don't have constant variance and shapiro test fails (significantly different from normally distributed). Look at the distribution of the model residuals to visually identify potential transformation. Data is negatively skewed. A reflection and log transformation might make the model residuals normally distributed. 

```{r}
density <- density(resid(mixed.lmer))

shapiro_test(resid(mixed.lmer))

transformed_data <- model_df_anomalies_removed

# makes auc_l positively skewed
transformed_data$auc_l <- 1000 - transformed_data$auc_l

transformed_data$auc_l <- log10(transformed_data$auc_l)

# make a model without the interaction term to check if an insecticide is having an effect at all concentrations
mixed.lmer_no_interaction_trans <- lmer(auc_l ~ concentration + insecticide + (1|day), data = transformed_data)

summary(mixed.lmer_no_interaction_trans)

mixed.lmer_trans <- lmer(auc_l ~ concentration * insecticide + (1|day), data = transformed_data)

summary(mixed.lmer_trans)

plot(mixed.lmer_trans)

qqnorm(resid(mixed.lmer_trans))

qqline(resid(mixed.lmer_trans))

# model and term significance.
full.lmer_trans <- lmer(auc_l ~ concentration * insecticide + (1|day), data = transformed_data, REML = FALSE)

reduced.lmer_trans <- lmer(auc_l ~ concentration + insecticide + (1|day), data = transformed_data, REML = FALSE)

anova(reduced.lmer_trans, full.lmer_trans) 

drop1(full.lmer_trans,test="Chisq")

# normality test
trans_shapiro_result <- shapiro_test(resid(mixed.lmer_trans))

trans_shapiro_result

# plot distribution of model residuals again
trans_density <- density(resid(mixed.lmer_trans))

# sort out title
par(mfrow = c(1, 2), cex.main = 0.8)

plot(density, main = "Residuals Distribution")

plot(trans_density, main = "Log Transformed Residuals Distribution")
```

Model residuals look closer to a normal distribution and shapiro wilks test now fails. 10% chance of observing this result if the model residuals were normally distributed.

Interaction between thiacloprid and concentration is still significant. 

I ran the analysis again without Thiacloprid-1-6, the only outlier with a standardised residual > 5. Now my data passes a Shapiro Wilks Test. All this means is "I cannot reject the hypothesis that the model residuals come from a population which has a normal distribution". Due to this vaguery I ran my analysis with and without the observation. The interaction between Thiacloprid and Concentration was significant in comparison to the interaction between Control and Concentration for both. 

Because I'm making so many contrasts in my model I'm not avoiding multiple hypothesis test anyway. Analyse Thiacloprid separately. Makes everything clearer. 

```{r}
thia_trans <- transformed_data [grep(pattern = "thiacloprid", x = transformed_data$insecticide),]

mixed.lmer_trans_thia <- lmer(auc_l ~ concentration + (1|day), data = thia_trans)

summary(mixed.lmer_trans_thia)

qqnorm(resid(mixed.lmer_trans_thia))

qqline(resid(mixed.lmer_trans_thia))

plot(mixed.lmer_trans_thia)

# plot distribution of model residuals again
trans_density_thia <- density(resid(mixed.lmer_trans_thia))

plot(trans_density_thia, main = "Log Transformed Residuals Distribution")

trans_shapiro_result_thia <- shapiro_test(resid(mixed.lmer_trans_thia))

trans_shapiro_result_thia
```

Above I have had concentration as a factor. When concentration is a factor observations must be independent, homogeneity of variance has to be constant and the model residuals have to be normally distributed. This is why I performed the reflection and log transformation. 

To avoid the issue in the above models of the insecticide reference level having an effect on the interaction term values I am going to set concentration as a continuous variable, assign the controls their own level within the insecticide factor and assign each control observation a random concentration. I'm then going to contruct a model with factorial (insecticide) and continuous (concentration) explanatory variables:

AUC = (intercept + insecticide coefficient) + (insecticide:concentration * concentration * CONCENTRATION)

Intercept = control level of insecticide factor

insecticide coefficient = what the intercept has to be modified by for each insecticide. For example, if acetamiprid-0.001 (which will become acet-0 once adjusted) is greater than control-0.001 (which will become control-0 once adjusted) then acet coefficient with add a value to the intercept. This is an additive coefficient.

CONCENTRATION = the adjusted value of concentration (0,1,2,3,3.7)

concentration = The coefficient for the control level of the insecticide factor for concentration. Should be close to 0. This is a multiplicative factor coefficient. Times this by the CONCENTRATION value.  

insecticide:concentration = what the coefficient for the control level of the insecticide factor for concentration has to be modified by to accurately represent the effect on growth of concentration for the respective insecticide. 

What I'm doing is fitting a model that consists of nine lines with different slopes as well as different intercepts. Each line is a level in the insecticide factor. If interaction terms are significant is shows that the slope for the insecticide is significantly different to the control In other words there is a significant dose response for that insecticide. 

In a perfect world I would add 56 more controls and have conc 0,0.001,0.01,0.1,1 and 5 for each insecticide factor. So 48 controls in the control level (all with conc 0) and another 8 controls distributed to the conc 0 levels of each insecticide. Then intercept would be 0 not 0.001. Doesnt matter too much though. I can still see the effect of acetamiprid this way by looking at intercept. 

Now concentration is continuous there needs to be a linear relationship between AUC and conc. Plot AUC vs conc with observations coloured according to insecticide. Is the data positively skewed? Yes so log transform concentration. First x1000 to make 0.001 -> 0. That's better. 

```{r}
concs_own_level$insecticide <- as.factor(concs_own_level$insecticide)

concs_own_level$insecticide <- relevel(concs_own_level$insecticide, "control")

plot(auc_l ~ concentration, 
     col = insecticide, 
     data = concs_own_level,
     xlab = "concentration (µM)",
     ylab = "Growth (AUC)")

concs_own_level$concentration <- log10(as.numeric(concs_own_level$concentration) * 1000)

plot(auc_l ~ concentration, 
     col = insecticide, 
     data = concs_own_level,
     xlab = "concentration (µM)",
     ylab = "Growth (AUC)")
```

Now make a model so we can investigate model diagnostics.

```{r}
mixed.lmer_conc_contin <- lmer(auc_l ~ concentration * insecticide + (1|day), data = concs_own_level)

drop1(mixed.lmer_conc_contin, test = "F")

summary(mixed.lmer_conc_contin)

plot(mixed.lmer_conc_contin)

qqnorm(resid(mixed.lmer_conc_contin))

qqline(resid(mixed.lmer_conc_contin))

```

Make a model without the interaction term

```{r}
mixed.lmer_conc_contin_no_int <- lmer(auc_l ~ concentration + insecticide + (1|day), data = concs_own_level)

drop1(mixed.lmer_conc_contin_no_int, test = "F")

summary(mixed.lmer_conc_contin_no_int)

plot(mixed.lmer_conc_contin_no_int)

qqnorm(resid(mixed.lmer_conc_contin_no_int))

qqline(resid(mixed.lmer_conc_contin_no_int))

```

Need to do transformation (reflection and log of AUC) again.

```{r}
concs_own_level_trans <- concs_own_level

# makes auc_l positively skewed
concs_own_level_trans$auc_l <- 1000 - concs_own_level_trans$auc_l

concs_own_level_trans$auc_l <- log10(concs_own_level_trans$auc_l)

mixed.lmer_conc_contin_trans <- lmer(auc_l ~ concentration * insecticide + (1|day), data = concs_own_level_trans)

drop1(mixed.lmer_conc_contin_trans, test = "F")

summary(mixed.lmer_conc_contin_trans)

plot(mixed.lmer_conc_contin_trans)

qqnorm(resid(mixed.lmer_conc_contin_trans))

qqline(resid(mixed.lmer_conc_contin_trans))

conc_contin_trans_shapiro_result <- shapiro_test(resid(mixed.lmer_conc_contin_trans))

conc_contin_trans_shapiro_result
```

Let's visualise this model.

```{r}
p1 <- ggplot(data = concs_own_level_trans) +  # which data frame to use
  aes(x = concentration, y = auc_l, colour = insecticide) + # specify the 'aesthetics'
  geom_point() + # add layer with points plotted
  geom_smooth(method= "lm", se = FALSE) + # add lines  <<- is this right?
  scale_color_brewer(palette = "Paired") + # use the viridis palette
  theme_bw() + # use a better theme than the nasty default one
  labs(x = "concentration (µM)", y = "Growth (AUC)") + # axis labels
  scale_y_reverse() # reverse scales to make interpretation more intuitive

p1
```

Randomly assign controls to each concentration, ensuring one from each day. Create function to do that. 


For a visualisation of mean AUC vs concentration for each insecticide (control part of insecticide)

```{r}
mean_plots_function <- function(d_gc) {
  
conditions_separately <- list()
conditions_stats <- tibble()

conditions <- c("control-", "acetamiprid-0.001", "acetamiprid-0.01", "acetamiprid-0.1", "acetamiprid-1","acetamiprid-5", "chlorpyrifos-0.001", "chlorpyrifos-0.01", "chlorpyrifos-0.1", "chlorpyrifos-1","chlorpyrifos-5", "clothianidin-0.001", "clothianidin-0.01", "clothianidin-0.1", "clothianidin-1","clothianidin-5", "cypermethrin-0.001", "cypermethrin-0.01", "cypermethrin-0.1", "cypermethrin-1", "cypermethrin-5", "flupyradifurone-0.001", "flupyradifurone-0.01", "flupyradifurone-0.1", "flupyradifurone-1","flupyradifurone-5", "imidacloprid-0.001", "imidacloprid-0.01", "imidacloprid-0.1", "imidacloprid-1","imidacloprid-5", "malathion-0.001", "malathion-0.01", "malathion-0.1", "malathion-1", "malathion-5", "sulfoxaflor-0.001", "sulfoxaflor-0.01", "sulfoxaflor-0.1", "sulfoxaflor-1", "sulfoxaflor-5", "tefluthrin-0.001", "tefluthrin-0.01", "tefluthrin-0.1", "tefluthrin-1", "tefluthrin-5", "thiacloprid-0.001", "thiacloprid-0.01", "thiacloprid-0.1", "thiacloprid-1", "thiacloprid-5")

for (name in 1:length(conditions)) {
  
  conditions_grouped <- d_gc %>% filter(str_detect(sample, conditions[name]))
  
  conditions_separately [name] <- conditions_grouped [ ,9]
  
  names(conditions_separately) [name] <- conditions[name]
  
  summ_stat <- stat.desc(conditions_separately[[name]])
  
  conditions_stats [name, 1] <- conditions[name]
  
  for (i in 1:length(summ_stat)) {
    
    conditions_stats [name, i+1] <- summ_stat [i]
    
  }
  
}

colnames(conditions_stats) <- c("condition", "nbr.val", "nbr.null", "nbr.na", "min", "max", "range", "sum", "median", "mean", "SE.mean", "CI.mean.0.95", "var", "std.dev", "coef.var")

# pull out condition AUC mean and AUC mean CI 95%
rel_conditions_stats <<- conditions_stats [ , c(1, 10, 12)]

# separate each insecticide
insecticide_names <- c("acetamiprid", "chlorpyrifos", "clothianidin", "flupyradifurone", "imidacloprid", "malathion", "tefluthrin", "thiacloprid")

insecticide_list <- list()

for (name in 1:length(insecticide_names)) {

  insecticide_pattern <- paste0(insecticide_names[name], "-\\d*", sep = "")
  
  insecticide_x <- rel_conditions_stats %>% filter(str_detect(condition, insecticide_pattern))

  insecticide_list [[name]]  <- insecticide_x
  
  names(insecticide_list) [[name]] <- insecticide_names[name]
  
}

insecticide_list_1 <- list()

concentration <- c(0.001, 0.01, 0.1, 1, 5)

for (insecticide in 1:length(insecticide_list)) {
  
  insecticide_concs <- cbind(insecticide_list [[insecticide]], concentration)
  
  insecticide_list_1 [[insecticide]]  <- insecticide_concs
   
  names(insecticide_list_1) [[insecticide]] <- insecticide_names[insecticide]

}

# make control row
control_stats <- rel_conditions_stats %>% filter(str_detect(condition, "control"))
control_conc <- 0.0001
control_row <- cbind(control_stats, control_conc)
colnames(control_row) <- colnames(insecticide_list_1[[1]])

# bind it to the other insecticide dataframes
insecticide_list_2 <- list()

for (insecticide in 1:length(insecticide_list_1)) {
  
  insecticide_control <- rbind(insecticide_list_1 [[insecticide]], control_row)
  
  insecticide_list_2 [[insecticide]]  <- insecticide_control
   
  names(insecticide_list_2) [[insecticide]] <- insecticide_names[insecticide]

}

require(scales)

plot_list <- list()

for (insecticide in 1:length(insecticide_list_2)) {
  
  title <- paste0(names(insecticide_list_2[insecticide]), sep = "" )
  
  df <- insecticide_list_2[[insecticide]]

  df$facet <- ifelse(df$concentration == min(df$concentration), 1, 2)
  
  drc <- ggplot(df, aes(x=concentration,y=mean)) +
    geom_point(data = subset(df, facet == 1)) +
    geom_point(data = subset(df, facet == 2)) +
    scale_x_log10(breaks = c(0.0001, 10^(-3:10)), 
                labels = c(0, math_format()(-3:10))) +
    geom_errorbar(aes(ymin=mean-CI.mean.0.95, ymax=mean+CI.mean.0.95), width=.1) + 
    ylim(0, 900) +
    ggtitle(title) +
    labs(x="", y="",size=1) +
    facet_grid(~facet, scales = 'free', space = 'free') +
    theme(panel.background = element_rect(fill = "white"),
    axis.line = element_line(), strip.text.x = element_blank()
    )
  
  plot_list [[insecticide]] <- drc

}

return(plot_list)

}

mean_plots <- mean_plots_function(d_gc)

add_global_label <- function(pwobj, Xlab = NULL, Ylab = NULL, Xgap = 0.03, Ygap = 0.03, ...) {
    ylabgrob <- patchwork::plot_spacer()
    if (!is.null(Ylab)) {
        ylabgrob <- ggplot() +
            geom_text(aes(x = .5, y = .5), label = Ylab, angle = 90, ...) +
            theme_void()
    }
    if (!is.null(Xlab)) {
        xlabgrob <- ggplot() +
            geom_text(aes(x = .5, y = .5), label = Xlab, ...) +
            theme_void()
    }
    if (!is.null(Ylab) & is.null(Xlab)) {
        return((ylabgrob + patchworkGrob(pwobj)) + 
            patchwork::plot_layout(widths = 100 * c(Ygap, 1 - Ygap)))
    }
    if (is.null(Ylab) & !is.null(Xlab)) {
        return((ylabgrob + pwobj) + 
            (xlabgrob) +
            patchwork::plot_layout(heights = 100 * c(1 - Xgap, Xgap),
                                   widths = c(0, 100),
                                   design = "
                                   AB
                                   CC
                                   "
            ))
    }
    if (!is.null(Ylab) & !is.null(Xlab)) {
        return((ylabgrob + pwobj) + 
            (xlabgrob) +
            patchwork::plot_layout(heights = 100 * c(1 - Xgap, Xgap),
                                   widths = 100 * c(Ygap, 1 - Ygap),
                                   design = "
                                   AB
                                   CC
                                   "
            ))
    }
    return(pwobj)
}

add_global_label((wrap_plots(mean_plots)),
                 Ylab = "AUC", Xlab = "Concentration")
```

For a visualisation of mean AUC vs concentration for each insecticide (control (no insecticide)) separate.

```{r}
control_sep_mean_plots_function <- function(d_gc) {
  
conditions_separately <- list()
conditions_stats <- tibble()

conditions <- c("control-0.001", "control-0.01","control-0.1","control-1","control-5", "acetamiprid-0.001", "acetamiprid-0.01", "acetamiprid-0.1", "acetamiprid-1","acetamiprid-5", "chlorpyrifos-0.001", "chlorpyrifos-0.01", "chlorpyrifos-0.1", "chlorpyrifos-1","chlorpyrifos-5", "clothianidin-0.001", "clothianidin-0.01", "clothianidin-0.1", "clothianidin-1","clothianidin-5", "cypermethrin-0.001", "cypermethrin-0.01", "cypermethrin-0.1", "cypermethrin-1", "cypermethrin-5", "flupyradifurone-0.001", "flupyradifurone-0.01", "flupyradifurone-0.1", "flupyradifurone-1","flupyradifurone-5", "imidacloprid-0.001", "imidacloprid-0.01", "imidacloprid-0.1", "imidacloprid-1","imidacloprid-5", "malathion-0.001", "malathion-0.01", "malathion-0.1", "malathion-1", "malathion-5", "sulfoxaflor-0.001", "sulfoxaflor-0.01", "sulfoxaflor-0.1", "sulfoxaflor-1", "sulfoxaflor-5", "tefluthrin-0.001", "tefluthrin-0.01", "tefluthrin-0.1", "tefluthrin-1", "tefluthrin-5", "thiacloprid-0.001", "thiacloprid-0.01", "thiacloprid-0.1", "thiacloprid-1", "thiacloprid-5")

for (name in 1:length(conditions)) {
  
  conditions_grouped <- d_gc %>% filter(str_detect(sample, conditions[name]))
  
  conditions_separately [name] <- conditions_grouped [ ,9]
  
  names(conditions_separately) [name] <- conditions[name]
  
  summ_stat <- stat.desc(conditions_separately[[name]])
  
  conditions_stats [name, 1] <- conditions[name]
  
  for (i in 1:length(summ_stat)) {
    
    conditions_stats [name, i+1] <- summ_stat [i]
    
  }
  
}

colnames(conditions_stats) <- c("condition", "nbr.val", "nbr.null", "nbr.na", "min", "max", "range", "sum", "median", "mean", "SE.mean", "CI.mean.0.95", "var", "std.dev", "coef.var")

# pull out condition AUC mean and AUC mean CI 95%
rel_conditions_stats <- conditions_stats [ , c(1, 10, 12)]

# separate each insecticide
insecticide_names <- c("control", "acetamiprid", "chlorpyrifos", "clothianidin", "flupyradifurone", "imidacloprid", "malathion", "tefluthrin", "thiacloprid")

insecticide_list <- list()

for (name in 1:length(insecticide_names)) {

  insecticide_pattern <- paste0(insecticide_names[name], "-\\d*", sep = "")
  
  insecticide_x <- rel_conditions_stats %>% filter(str_detect(condition, insecticide_pattern))

  insecticide_list [[name]]  <- insecticide_x
  
  names(insecticide_list) [[name]] <- insecticide_names[name]
  
}

insecticide_list_1 <- list()

concentration <- c(0.001, 0.01, 0.1, 1, 5)

for (insecticide in 1:length(insecticide_list)) {
  
  insecticide_concs <- cbind(insecticide_list [[insecticide]], concentration)
  
  insecticide_list_1 [[insecticide]]  <- insecticide_concs
   
  names(insecticide_list_1) [[insecticide]] <- insecticide_names[insecticide]

}

require(scales)

plot_list <- list()

for (insecticide in 1:length(insecticide_list_1)) {
  
  title <- paste0(names(insecticide_list_1[insecticide]), sep = "" )
  
  df <- insecticide_list_1[[insecticide]]
  
  
  drc <- ggplot(df, aes(x=concentration,y=mean)) +
    geom_point() +
    scale_x_log10(breaks = c(0.0001, 10^(-3:10)), 
                labels = c(0, math_format()(-3:10))) +
    geom_errorbar(aes(ymin=mean-CI.mean.0.95, ymax=mean+CI.mean.0.95), width=.1) + 
    ylim(0, 900) +
    ggtitle(title) +
    labs(x="", y="",size=1) +
    theme(panel.background = element_rect(fill = "white"),
    axis.line = element_line(), strip.text.x = element_blank()
    )
  
  plot_list [[insecticide]] <- drc

}

return(plot_list)

}

control_sep_mean_plots <- control_sep_mean_plots_function(d_gc)

add_global_label((wrap_plots(control_sep_mean_plots)),
                 Ylab = "AUC", Xlab = "Concentration")
```

Plot individual replicates by day for each insecticide with a line connecting them.

```{r}
formatted_growthcurver_df <- aucl_formatting_function(growthcurver_data = growthcurver_data, aucl_or_r = 9)
```

Split by insecticide

```{r}
by_insecticide_df_function <- function(formatted_growthcurver_df) {
  
  # split assigned_controls_df into 8 lists by insecticide. Also split each insecticide by day. 

  # define 8 insecticides
  eight_insecticides <- c("control", "acetamiprid", "chlorpyrifos", "clothianidin", "flupyradifurone", "imidacloprid", "malathion", "tefluthrin", "thiacloprid")
  
  # create list to save loop output
  insecticide_list <- list()
  
  # split insecticides into their own dfs within a list
  for (insecticide in 1:length(eight_insecticides)) {
    
    insecticide_alone <- formatted_growthcurver_df [grep(pattern = eight_insecticides [insecticide], x = formatted_growthcurver_df$insecticide), ]
    
    insecticide_list [[insecticide]] <- insecticide_alone
    
    names(insecticide_list) [[insecticide]] <- eight_insecticides[insecticide]
    
  }
  
  return(insecticide_list)
  
}

by_insecticide_dfs <- by_insecticide_df_function(formatted_growthcurver_df)

```

Plot controls separate from insecticide. Get an idea of variation between insecticides. 

```{r}
plot_list <- list()

for (insecticide in 1:length(by_insecticide_dfs)) {
  
  title <- paste0(names(by_insecticide_dfs[insecticide]), sep = "" )
  
  df <- by_insecticide_dfs[[insecticide]]

  drc <- ggplot(df, aes(x=concentration, y=auc_l, color=day)) +
    geom_point() +
    geom_line() +
    # need to change concentration to numeric
    scale_x_log10(breaks = trans_breaks("log10", function(x) 10^x),
                  labels = trans_format("log10", math_format(10^.x))) + ylim(0, 1500) +
    ggtitle(title) +
    labs(x="", y="") +
    theme(panel.background = element_rect(fill = "white"), axis.line = element_line(), axis.title = element_text(size = 10),
          plot.title = element_text(size = 12))
  
  plot_list [[insecticide]] <- drc

}

add_global_label((wrap_plots(plot_list)),
                 Ylab = "AUC", Xlab = "Concentration") + plot_layout(guides = "collect")
```

Does looking at growth rate (r) change any of the results? 

```{r}
model_df_anomalies_removed_r <- aucl_formatting_function(growthcurver_data = d_gc, aucl_or_r = 4)

transformed_data_r <- model_df_anomalies_removed_r

# makes r positively skewed
transformed_data_r$r <- 1000 - transformed_data_r$r

transformed_data_r$r <- log10(transformed_data_r$r)

trans_insect_conc_day_model_r <- lm(r ~ insecticide + concentration + day + insecticide*concentration, data = transformed_data_r)

summary(trans_insect_conc_day_model_r)
```

Interaction between thiacloprid and concentration is again significant. Less of the variation described by the model though.

Try and use a mixed model with day as a random effect. Difference between day explains 41% of the variance remaining after the variance explain by fixed effects. 

Only fitted random-intercept model. A random-intercept model allows the intercept to vary for each level of the random effects, but keeps the slope constant among them. The intercept in this case is the initial growth on a certain day. So growth on some days may be larger or smaller to begin with. This assumes that the relationship between growth and insecticide concentration is the same on all days. 

I could do a random-slope and random intercept model. This would allow both to intercept and slope to vary. So both baseline growth (intercept) and the relationship between growth and insecticide concentration (slope) can vary by day. However, I think it is unlikely for the relationship between growth and insecticide concentration to vary between days. Also, can't get it to work.

Testing significance becomes complex for mixed models. This guide ([mixed models](http://bbolker.github.io/mixedmodels-misc/glmmFAQ.html#inference-and-confidence-intervals)) runs through some options. Models need to be nested (mine are [link](https://www.stat.ncsu.edu/people/bloomfield/courses/st430/slides/MandS-ch04-sec13-14.pdf)). Reference for LRT of fixed effects ([link](https://www.ssc.wisc.edu/sscc/pubs/MM/MM_TestEffects.html))

```{r}
library(lme4)

mixed.lmer <- lmer(auc_l ~ insecticide*concentration + (1|day), data = transformed_data)

# how would i get this to work?
# mixed.lmer_1 <- lmer(auc_l ~ insecticide*concentration + (1 + insecticide*concentration|day), data = transformed_data)

summary(mixed.lmer)

plot(mixed.lmer)

# below will be same as above for linear model
qqnorm(resid(mixed.lmer))

qqline(resid(mixed.lmer))

# model and term significance.
full.lmer <- lmer(auc_l ~ insecticide*concentration + (1|day), data = transformed_data, REML = FALSE)

reduced.lmer <- lmer(auc_l ~ 1 + (1|day), data = transformed_data, REML = FALSE)

anova(reduced.lmer, full.lmer) 

drop1(full.lmer,test="Chisq")


```
The easiest way to avoid the issues associated with looking at the interaction terms is to look only at the 5mM concentration observations. Then all I have is one fixed factor. 