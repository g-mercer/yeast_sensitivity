---
title: "one_concentration"
author: "Guy Mercer"
date: "25/02/2021"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE, message = FALSE, warning = FALSE)
```

Machine Settings:

* Number of Cycles - 193

* Cycle Length - 300s

* Wavelength - 600nm

* Temperature - 30°C

* Shake - Before Each Cycle (267s)

* Shake Mode - Double Orbital

* Shake Frequency - 200rpm

* Total Well Volume - 200µl

I combined all the replicates using zsh to output a formatted, compiled csv file called formatted_compiled. I then edited the names of controls and blanks.

```{zsh raw-file-formatting}
#!/usr/bin/env zsh

# setwd
cd /Users/guy/Documents/phd/DEG_yeast_insecticide_expt/senstivity_test/2_strain

./WHATIDID.sh 
```

```{r}
library(tidyverse)
library(knitr)
library(growthcurver)
library(pastecs)
library(rstatix)
library(lmerTest)
library(ggpubr)
library(broom)
library(patchwork)
library(boot)
library(ggtext)
library(cowplot)
``` 

```{r}
# set wd
setwd("~/Documents/phd/DEG_yeast_insecticide_expt/senstivity_test/2_strain/")

# read csv
insect_sens <- read.csv(file = "./results/formatted_compiled.csv", header = FALSE, stringsAsFactors = FALSE)

# formatting function
sens_data_form <- function(sens_data) {
  # transpose
  sens_data_trans <- t(sens_data)
  # save first row as colnames
  colnames(sens_data_trans) <- sens_data_trans [1, ]
  # delete first row, which is now duplicate of colnames
  sens_data_colnames <- sens_data_trans [-1, ]
  # remove any empty rows. Sometimes created when importing csv file 
  sens_data_no_blanks <- sens_data_colnames[rowSums(is.na(sens_data_colnames)) != ncol(sens_data_colnames),]
  # convert matrix into dataframe
  sens_data_df <- as.data.frame(sens_data_no_blanks)
  # convert everything to numeric
  sens_data_df[] <- lapply(sens_data_df, function(x) {
    if(is.factor(x)) as.numeric(as.character(x)) else x
  })
  # convert to data frame
  sens_data_corr <- as.data.frame(sens_data_df)
  # separate blanks
  blanks <- sens_data_corr [, grep(pattern = "blank", x = colnames(sens_data_corr))]
  # remove blanks
  sens_data_corr <- sens_data_corr [, -grep(pattern = "blank", x = colnames(sens_data_corr))]
  # take mean of each row
  blanks_mean <- rowMeans(blanks)
  # correct for blank
  sens_data_corr <- sens_data_corr [, -1] - blanks_mean
  # add time again
  time <- seq(0, 960, by = 5)
  sens_data_corr <- cbind(as.data.frame(time), sens_data_corr)
  
  return(sens_data_corr)
}

sens_data_corr <- sens_data_form(insect_sens)

# set any negative values to 0
sens_data_corr[sens_data_corr<0] <- 0

```

To input the data into Growthcurver I had to alter the formatting. When using Growthcurver, columns have to be looped through individually for a more detailed output. Growth curve data is fitted to the standard form of the logistic equation (sigmoidal).

I know thia-pdr-2.2 returns 0 for everything and stops the function from progressing. Therefore, I am removing it as this stage (as it would be removed later as it isn't the median value of it technical replicate trio. This is why I performed technical replicates. 

```{r}
sens_data_corr <- sens_data_corr [, -grep(pattern = "thiacloprid-pdr-2.2", x = colnames(sens_data_corr))]
```


```{r, include = FALSE}
growthcurver_function <- function(sens_data_corr) {
  
# Let's create an output data frame to store the results in. 
# We'll create it so that it is the right size (it's faster this way!), 
# but leave it empty.
num_analyses <- length(names(sens_data_corr)) - 1
d_gc <- data.frame(sample = character(num_analyses),
                   k = numeric(num_analyses),
                   n0  = numeric(num_analyses),
                   r = numeric(num_analyses),
                   r_se = numeric(num_analyses),
                   r_p = numeric(num_analyses),
                   t_mid = numeric(num_analyses),
                   t_gen = numeric(num_analyses),
                   auc_l = numeric(num_analyses),
                   auc_e = numeric(num_analyses),
                   sigma = numeric(num_analyses),
                   stringsAsFactors = FALSE)

# Now, loop through all of the columns in the data frame. For each column,
# run Growthcurver, save the most useful metrics in the output data frame,
# and make a plot of all the growth curve data and their best fits.
par(mfrow = c(1,1))
#par(mar = c(1,1,1,1))
y_lim_max <- max(sens_data_corr[,setdiff(names(sens_data_corr), "time")]) - min(sens_data_corr[,setdiff(names(sens_data_corr), "time")])

n <- 1    # keeps track of the current row in the output data frame
for (col_name in names(sens_data_corr)) {
  
  # Don't process the column called "time". 
  # It contains time and not absorbance data.
  if (col_name != "time") {
    
    # Create a temporary data frame that contains just the time and current col
    sens_data_corr_loop <- sens_data_corr[, c("time", col_name)]
    
    # Now, call Growthcurver to calculate the metrics using SummarizeGrowth
    gc_fit <- SummarizeGrowth(data_t = sens_data_corr_loop[, "time"], 
                              data_n = sens_data_corr_loop[, col_name],
                              bg_correct = "none")
    
    # Now, add the metrics from this column to the next row (n) in the 
    # output data frame, and increment the row counter (n)
    d_gc$sample[n] <- col_name
    d_gc[n, 2:11] <- c(gc_fit$vals$k,
                       gc_fit$vals$n0,
                       gc_fit$vals$r,
                       gc_fit$vals$r_se,
                       gc_fit$vals$r_p,
                       gc_fit$vals$t_mid,
                       gc_fit$vals$t_gen,
                       gc_fit$vals$auc_l,
                       gc_fit$vals$auc_e,
                       gc_fit$vals$sigma)
    n <- n + 1
    
    
    # Finally, plot the raw data and the fitted curve
    n_obs <- length(gc_fit$data$t)
    plot(gc_fit$data$t, gc_fit$data$N, 
      pch = 20, 
      xlim = c(0, 960), 
      ylim = c(0, y_lim_max),
      xlab="time", ylab="Absorbance (600nm)",
      cex = 0.6, xaxt = "n", yaxt = "n")
    text(x = 960 / 2, y = y_lim_max, labels = col_name, pos = 1)
    lines(gc_fit$data$t, predict(gc_fit$model),col = "red")
    axis(1, at = seq(0, 960, by = 60), las=2)
    axis(2, at = seq(0, 2, by = 1), las=2)


  }
}

# Uncomment the next line to save the plots from your 96-well plate to a file
# dev.off()

return(d_gc)

}

d_gc <- growthcurver_function(sens_data_corr = sens_data_corr)

search_term <- c("time","thiacloprid-pdr", "control-neg-pdr")

thia_control <- tibble(matrix(0,193,0))

for (i in 1:length(search_term)) {
  
  group <- sens_data_corr [, grep(pattern = search_term [i], x = colnames(sens_data_corr))]
  
  thia_control <- cbind(thia_control, group)
  
}

thia_control <- thia_control [, -1]

colnames(thia_control) [1] <- "time"

thia_control <- thia_control [,c(1,2,22)]

# plots
 pdf(file = "/Users/guy/Documents/phd/DEG_yeast_insecticide_expt/senstivity_test/2_strain/example_growth_curves.pdf",   # The directory you want to save the file in
     width = 6, # The width of the plot in inches
     height = 4) # The height of the plot in inches

example_plots <- growthcurver_function(sens_data_corr = thia_control)

dev.off()
```

I didn't actually perform a control positive in the end. All they are is 100µl of yeast stock. Quite cool because they show how half the volume really affects the smoothness of the curve. Remove them. Also, one of the thiacloprid is coming back as 0 for everything. This is causing the plotting part of the growthcurver function to fail. The readings performed on the same day are technical replicates so let's select the median value based on auc_l

```{r, include = FALSE}
# remove control-pos
d_gc <- d_gc [-grep(pattern = "control-pos", x = d_gc$sample), ]

# Show the top 50 samples with the largest sigma value 
# (with the worst model fit to the growth curve data)
high_sigma <- d_gc %>% top_n(50, sigma) %>% arrange(desc(sigma))

# look at some of top 50 sigma observations
high_sigma_obser <- c("time", high_sigma$sample)

high_sigma_obser_df <- matrix(0, nrow = 193, ncol = length(high_sigma_obser))

for (i in 1:length(high_sigma_obser)) {
  
  only <- paste0("^", high_sigma_obser [i], "$", sep = "")
  
  high_sigma_plots <- sens_data_corr [, grep(pattern = only, x = colnames(sens_data_corr))]

  high_sigma_obser_df [, i] <- high_sigma_plots
}

colnames(high_sigma_obser_df) <- high_sigma_obser

high_sigma_obser_df <- as.data.frame(high_sigma_obser_df)

growthcurver_function(sens_data_corr = high_sigma_obser_df)
```

Highlight growthcurver_function(sens_data_corr = high_sigma_obser_df) and run to see graphs. These are the poorest fits to the logistic regression and none by visual inspection look particularly worrying. Perform a pca on all the data. Save as a pdf to get a proper look at it. All the thiacloprid pdr observations don't cluster with the main group but that's no surprise. Decide not to remove anything as there are no obvious outliers. 

```{r}
pca_gc_out <- as_tibble(d_gc) 

# Prepare the gc_out data for the PCA
rownames(pca_gc_out) <- pca_gc_out$sample

# Do the PCA
pca.res <- prcomp(pca_gc_out %>% select(k:sigma), center=TRUE, scale=TRUE)

pdf(file="results/pca.pdf") 
# Plot the results
as_tibble(list(PC1=pca.res$x[,1],
                   PC2=pca.res$x[,2],
                   samples = rownames(pca_gc_out))) %>% 
  ggplot(aes(x=PC1,y=PC2, label=samples)) + 
geom_text(size = 1)
dev.off()
```

Next, split the data in groups of technical replicates, choose only the median and recombine. 

```{r}
# grab only names without a .
dotless <- d_gc$sample [grep(pattern = "^([[:alpha:]]+-){1,}[[:digit:]]+$", x = d_gc$sample)]

# take only sample name and auc_l from d_gc
total_growth <- as.data.frame(cbind(d_gc$sample, d_gc$auc_l))
colnames(total_growth) <- c("sample", "auc_l")
total_growth$auc_l <- as.numeric(as.character(total_growth$auc_l))

# separate technical replicates into their own groups in a list
tech_rep_list <- list()

for (i in 1:length(dotless)) {
  
  technical_replicates <- total_growth [grep(pattern = dotless [i] , x = d_gc$sample) ,]

  tech_rep_list [[i]] <- technical_replicates
  
}

# calculate the median for each group of technical replicates in the list
auc_l <- sapply(tech_rep_list, function(x){
  
  auc_l <- x [, 2]
  
  median <- median(auc_l)
  
  return(median)
})

# combine median with technical replicate group name
data_for_stats <- as.data.frame(cbind(dotless,auc_l))
data_for_stats$dotless <- as.character(data_for_stats$dotless)
data_for_stats$auc_l <- as.numeric(as.character(data_for_stats$auc_l))
```

This data is now ready almost ready for analysis. Next I need to add relevant columns for insecticide and strain fixed effects and day random effect

```{r}
# get only controls
dotlesss <- data_for_stats [grep(pattern = "^([[:alpha:]]+-){3,4}[[:digit:]]+$", x = data_for_stats$dotless), ]

# delete controls from df
data_for_stats <- data_for_stats [-grep(pattern = "^([[:alpha:]]+-){3,4}[[:digit:]]+$", x = data_for_stats$dotless), ]

# specify where I want to change
name_corrections <- c("l-n", "o-s")

# remove - by looping through the position that need changing and putting a gsub within a gsub to specify the change i want to make
for (i in 1:length(name_corrections)){
  
  dotlesss$dotless <- gsub(name_corrections [i], gsub("-","", name_corrections [i]), dotlesss$dotless)
  
}

# reassociate renamed rows with df
data_for_stats <- rbind(data_for_stats,dotlesss)

# split names of samples by - and then saves these are their own columns. 
by_column_name <- tibble()

for (i in 1:nrow(data_for_stats)){
  
  split <- strsplit(data_for_stats [i, 1], split = "-")
  
  by_column_name [i, 1] <- split [[1]] [1]
  
  by_column_name [i, 2] <- split [[1]] [2]
  
  by_column_name [i, 3] <- split [[1]] [3]
}

data_for_stats <- cbind(data_for_stats, by_column_name)

colnames(data_for_stats) <- c("sample", "auc_l", "insecticide", "strain", "day")

# make insecticide factor and reorder
data_for_stats$insecticide <- as.factor(data_for_stats$insecticide)
data_for_stats$insecticide <- relevel(data_for_stats$insecticide, "controlneg")

# make strain and day factor
data_for_stats$strain <- as.factor(data_for_stats$strain)
data_for_stats$strain <- relevel(data_for_stats$strain, "pdr")

data_for_stats$day <- as.factor(data_for_stats$day)
```

Begin statistical analysis. Construct a linear mixed model. Check there is homogeneity of variance and residuals are normally distributed. 

```{r}
mixed_model <- lmer(auc_l ~ insecticide * strain + (1|day), data = data_for_stats)

summary(mixed_model)

plot(mixed_model)

qqnorm(resid(mixed_model))

qqline(resid(mixed_model))

plot(density(resid(mixed_model)))
```

```{r}
# residual variance explained by day. 
(7045/(7045+3258))*100
```

The difference between day explains 68.4%% of the variance left over after the variance explained by our fixed effects. 

Test Model Significance

```{r}
# model and term significance.
full.lmer <- lmer(auc_l ~ insecticide * strain + (1|day), data = data_for_stats, REML = FALSE)

reduced.lmer <- lmer(auc_l ~ insecticide + strain + (1|day), data = data_for_stats, REML = FALSE)

anova(reduced.lmer, full.lmer) 

drop1(full.lmer,test="Chisq")
```

For each group I want to calculate a CI. This isn't easy because my sample size is only 7 so I can't accurately determine if my groups are normally distributed. Therefore, I have to perform non parametric bootstrapping. 

```{r}
# boot function for boot. Indices have to be specified to allow sampling with replacement.
boot_function <- function(data, indices) {
  
  d <- data [indices]
  
  mean <- mean(d)
  
  return(mean)
  
}

# split all my data into respective groups
group_names <- sub("-[[:digit:]]", "", data_for_stats$sample) %>% unique()

list_of_groups <- list()

for (i in 1:length(group_names)) {
  
  group <- data_for_stats [ grep(pattern = group_names [i], x = data_for_stats$sample),]
  
  aucl_only <- group$auc_l
  
  list_of_groups [[i]] <- aucl_only
  
}

names(list_of_groups) <- group_names

boot_list <- lapply(list_of_groups, function(x) {
  
  boot(data = x, statistic = boot_function, R = 1000)
  
})

names(boot_list) <- group_names


ci_list <- lapply(boot_list, function(x) {
  
  boot.ci(x, conf = 0.95, type = "basic")
  
})

names(ci_list) <- group_names

# save the group name, mean, lower and upper 95% confidence interval in one dataframe.
ci_df <- matrix(0, 20, 4)

for (i in 1:length(ci_list)) {
  
  group_row <- c(names(ci_list) [i], ci_list [[i]] $t0, ci_list [[i]] $basic [c(4,5)])
  
  ci_df [i, ] <- t(group_row)
  
}

colnames(ci_df) <- c("group", "mean", "lower", "upper")
```

Next is do pairwise comparisons of my choice. Control solvent vs everything else for each strain. Below is the right package but wrong implementation. To get it to work I will have to combine the insecticide and strain factors. The output of the model below is misleading because everything is being compared to controlneg-pdr, which isn't correct. However, it doesn't matter because this model was only produced to get the multiple comparisons output and to check if they were the same as the model summary contrast values, which they are. 

```{r}
library(multcomp)

data_for_stats$insecticidestrain <- paste0(data_for_stats$insecticide,"-", data_for_stats$strain, sep = "")

# make insecticidestrain factor and reorder
data_for_stats$insecticidestrain <- as.factor(data_for_stats$insecticidestrain)
data_for_stats$insecticidestrain <- relevel(data_for_stats$insecticidestrain, "controlneg-pdr")

mixed_model_1 <- lmer(auc_l ~ insecticidestrain + (1|day), data = data_for_stats)

# summary(mixed_model_1)

# plot(mixed_model_1)

# qqnorm(resid(mixed_model_1))

# qqline(resid(mixed_model_1))

# plot(density(resid(mixed_model_1)))

# this takes ages to load but shows that the contrasts from the model output are the same as the pairwise comparison Tukey method (appropriate version for mixed models)
# summary(glht(mixed_model_1, linfct=mcp(insecticidestrain="Tukey")))
```

Below I extract the relevant pairwise comparisons from the mixed model, not the glht summary because they have the same values and they are easier to extract and handle from the mixed model contrast output. 

```{r}
p_pdr <- as.data.frame(summary(mixed_model) [[10]] [,1:5])

# make strain and day factor
data_for_stats$strain <- as.factor(data_for_stats$strain)
data_for_stats$strain <- relevel(data_for_stats$strain, "by")
data_for_stats$day <- as.factor(data_for_stats$day)

mixed_model_by_first <- lmer(auc_l ~ insecticide * strain + (1|day), data = data_for_stats)
p_by <- as.data.frame(summary(mixed_model_by_first) [[10]] [,1:5])

p <- rbind(p_pdr,p_by)

p <- p [c(2:10,22:30),]

# give rows correct names

strains <- c("pdr ", "by ")
searches <- c("^[[:lower:]]{11}[[:lower:]]*$", "^[[:lower:]]{11}[[:lower:]]*1$")


corr_named_p_values <- tibble()

for (i in 1:length(searches)) {
  
  strain_sep <- p [grep(pattern = searches [i], x = rownames(p)), ]
  
  rownames(strain_sep) <- gsub(pattern = "insecticide", replacement = strains [i], x = rownames(strain_sep))
  
  replacement_term <- paste0(" vs controlneg ", strains [i], sep = "")
  
  rownames(strain_sep) <- sub(pattern = "$", replacement = replacement_term, x = rownames(strain_sep))
  
  corr_named_p_values <- rbind(corr_named_p_values, strain_sep)

}

# perform FDR correction. Set a 5% false discovery rate
fdr <- p.adjust(corr_named_p_values$`Pr(>|t|)`, method = "fdr", n = length(corr_named_p_values$`Pr(>|t|)`))

fdr_p_values <- cbind(corr_named_p_values,fdr)
```

I considered retrieving the post hoc comparisons by making two models by strain. This, however, altered standard error and t values and was incorrect. Better to include all the information available. Above I did this but combined two factors to allow for the correct contrasts. This gave the same contrast output as the correct model where strain and insecticide were separate. I used the original model contrast output anyway, but switched the order of the strain factor to get the appropriate contrasts for both pdr and by (see above).

Publication Plots using knell code. 

```{r}
# do one with mean and CI first. As there are a lot of conditions split into two plots by strain
# but with the same y axis limits. 

# give ci_df insecticide and strain columns
# split names of samples by - and then saves these as their own columns. 
by_column_name <- tibble()

for (i in 1:nrow(ci_df)){
  
  split <- strsplit(ci_df [i, 1], split = "-")
  
  for (k in 1:length(split [[1]])){
    
     by_column_name [i, k] <- split [[1]] [k]
  }
  
}

ci_df <- cbind(ci_df, by_column_name)

colnames(ci_df) <- c("sample", "mean", "ci_l", "ci_h", "insecticide", "strain")

# make mean, ci_l and ci_h numeric
ci_df$mean <- as.numeric(as.character(ci_df$mean))
ci_df$ci_l <- as.numeric(as.character(ci_df$ci_l))
ci_df$ci_h <- as.numeric(as.character(ci_df$ci_h))

# to add p values from fdr_p_values use stat_pvalue_manual

# first create a df with group1 | group2 | p | y.position columns for each strain. (y position column isn't necessary if universal, denotes the y coordinates of the p-values in the plot)

# split fdr_p_values by strain
fdr_p_values_pdr <- fdr_p_values [grep(pattern = "pdr", x = rownames(fdr_p_values)),]
fdr_p_values_by <- fdr_p_values [grep(pattern = "by", x = rownames(fdr_p_values)),]

p_value_plot_overlay_function <- function(p_values_df, pattern1, pattern2) {
  
  # based on rownames give fdr_p_values_pdr two columns with the two groups being compared with the appropriate - in their name
  split_list <- str_split(rownames(p_values_df), "vs")
  
  group_names <- tibble()
  colnames(group_names) <- c("group-1", "group-2")
  
  for (i in 1:length(split_list)) {
    group_1 <- sub(pattern = " ", replacement = "-" , split_list [[i]][1]) %>% sub(pattern = " ", replacement = "") %>% sub(pattern = "1", replacement = "")
    group_names [i, 1] <- group_1 
    
    group_2 <- sub(pattern = " ", replacement = "" , split_list [[i]][2]) %>% sub(pattern = " ", replacement = "-") %>% sub(pattern = " ", replacement = "")
    group_names [i, 2] <- group_2 
    
  }
  
  for_plot_overlay <- cbind(group_names, p_values_df$fdr)
  colnames(for_plot_overlay) <- c("group1", "group2", "p.adj")
  
  for_plot_overlay$group1 <- gsub(pattern = pattern1, replacement = "", x = for_plot_overlay$group1)
  
  for_plot_overlay$group1 <- sapply(for_plot_overlay$group1, function(x) paste(x, pattern2, sep=""))
  
  for_plot_overlay <- add_significance(for_plot_overlay)
  
  for_plot_overlay$group1 <- gsub(pattern = pattern2, replacement = "", x = for_plot_overlay$group1)
  
  for_plot_overlay$group2 <- gsub(pattern = pattern2, replacement = "", x = for_plot_overlay$group2)
  
  return(for_plot_overlay)
  
}

p_values_plot_overlay_pdr <- p_value_plot_overlay_function(fdr_p_values_pdr, "pdr-", "-pdr")

p_values_plot_overlay_by <- p_value_plot_overlay_function(fdr_p_values_by, "by-", "-by")

knell_plot_function <- function(ci_df, data_for_stats, colour1, colour2, p_data, strain, fig_letter) {
  
  title <- paste0(fig_letter, "Growth Effects of Insecticides on ", strain, " at 1mM", sep = "")
  
  # set up the plot basics
  p1 <-
    ggplot(data = ci_df, aes(
      x = insecticide,
      y = mean,
      colour = as.factor(strain)
    )) +
    
    # Specify the y axis limits
    ylim(0, 1000) +
    
    # Add the points for the means  
    geom_point(position = position_dodge(width = 0.75), size = 3) +
    
    # Add the errorbars
    geom_errorbar(
      aes(
        x = insecticide,
        ymin = ci_l,
        ymax = ci_h,
        colour = as.factor(strain)
      ),
      position = position_dodge(width = 0.75),
      width = 0.1
    ) +
    
    # Add in the data with some transparency and jitter
    geom_point(
      data = data_for_stats,
      aes(
        x = insecticide,
        y = auc_l,
        colour = as.factor(strain)
      ),
      alpha = 0.4,
      position  = position_jitterdodge(),
      show.legend = FALSE
    ) +
    
    # Set the colours
    scale_color_manual(values = c(colour1, colour2)) +
    
    # Avoid the nasty default theme
    theme_bw() + 
    
    # Y axis label and the caption for the legend  
    labs(y = "Total Growth (AUC-l)", colour = "Strain") +
    
    theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1)) +
    
    ggtitle(title) +
    
    theme(plot.title = element_text(hjust = 0.5)) +
    
    theme(plot.title = ggtext::element_markdown()) +

    
    # add p-values
    stat_pvalue_manual(
      p_data, 
      y.position = 800, step.increase = 0.1,
      label = "p.adj.signif",
      size = 3,
      hide.ns = TRUE
    )
  
  
  # Plot the graph
  return(p1)
  
}

# for visualising pdr plots split data by strain and plot separately. 
ci_df_pdr <- ci_df [ci_df$strain == "pdr", ]
data_for_stats_pdr <- data_for_stats [data_for_stats$strain == "pdr", ]

# make insecticide factor and reorder
ci_df_pdr$insecticide <- as.factor(ci_df_pdr$insecticide)
ci_df_pdr$insecticide <- relevel(ci_df_pdr$insecticide, "controlneg")

data_for_stats_pdr$insecticide <- as.factor(data_for_stats_pdr$insecticide)
data_for_stats_pdr$insecticide <- relevel(data_for_stats_pdr$insecticide, "controlneg")

# for visualising by plots split data by strain and plot separately. 
ci_df_by <- ci_df [ci_df$strain == "by", ]
data_for_stats_by <- data_for_stats [data_for_stats$strain == "by", ]

# make insecticide factor and reorder
ci_df_by$insecticide <- as.factor(ci_df_by$insecticide)
ci_df_by$insecticide <- relevel(ci_df_by$insecticide, "controlneg")

data_for_stats_by$insecticide <- as.factor(data_for_stats_by$insecticide)
data_for_stats_by$insecticide <- relevel(data_for_stats_by$insecticide, "controlneg")

pdr_plot <- knell_plot_function(ci_df_pdr, data_for_stats_pdr, "steelblue", "firebrick4", p_values_plot_overlay_pdr, "*pdr1∆ pdr3∆*", "b) ")

by_plot <- knell_plot_function(ci_df_by, data_for_stats_by, "firebrick4", "steelblue", p_values_plot_overlay_by, "BY4741", "a) ")

# plots
 pdf(file = "/Users/guy/Documents/phd/DEG_yeast_insecticide_expt/senstivity_test/2_strain/pdr.pdf",   # The directory you want to save the file in
     width = 6, # The width of the plot in inches
     height = 4) # The height of the plot in inches

pdr_plot

 dev.off()

 pdf(file = "/Users/guy/Documents/phd/DEG_yeast_insecticide_expt/senstivity_test/2_strain/by.pdf",   # The directory you want to save the file in
     width = 6, # The width of the plot in inches
     height = 4) # The height of the plot in inches

by_plot

dev.off()
```

Before getting carried away with any of these results remember that 1mM thiacloprid = 253ppm or 253000ppb....at least 2 orders of magnitude higher than a field realistic dose. For checking if t distributions can be used for CIs look at distribution of each group separately. 

```{r}
# generating supplementary tables 
p_by_table <- p_by [1:10,]

write.csv(p_by_table, "~/Documents/phd/DEG_yeast_insecticide_expt/senstivity_test/2_strain/p_by_table.csv", row.names = TRUE)

p_pdr_table <- p_pdr [1:10,]

write.csv(p_pdr_table, "~/Documents/phd/DEG_yeast_insecticide_expt/senstivity_test/2_strain/p_pdr_table.csv", row.names = TRUE)

```

```{r}
# fiddling around with cowplot in the future. Here is the basic structure. Will have to alter plot function to 
# remove titles in order to apply global title. 
plot_row <- plot_grid(by_plot, pdr_plot, labels = "auto")

# now add the title
title <- ggdraw() + 
  draw_label(
    "Miles per gallon decline with displacement and horsepower",
    fontface = 'bold',
    x = 0,
    hjust = 0
  ) +
  theme(
    # add margin on the left of the drawing canvas,
    # so title is aligned with left edge of first plot
    plot.margin = margin(0, 0, 0, 7)
  )
plot_grid(
  title, plot_row,
  ncol = 1,
  # rel_heights values control vertical title margins
  rel_heights = c(0.1, 1)
)
```

